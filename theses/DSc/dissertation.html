<!DOCTYPE html> 
<html> 
<head> <title></title> 
<meta charset="UTF-8" /> 
<meta name="generator" content="TeX4ht (http://www.cse.ohio-state.edu/~gurari/TeX4ht/)" /> 
<link rel="stylesheet" type="text/css" href="dissertation.css" /> 
<!-- for beautifying --><link rel="stylesheet" type="text/css" href="site.css" /> 
<script type="text/x-mathjax-config"> MathJax.Hub.Config({ extensions: ["tex2jax.js"], jax: ["input/TeX", "output/HTML-CSS"], tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], displayMath: [ ['$$','$$'], ["\\[","\\]"] ], processEscapes: true }, "HTML-CSS": { availableFonts: ["TeX"] } }); </script> <script type="text/javascript" 
src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" 
></script> 
</head><body 
>
  <div class="maketitle">
<span 
class="cmr-17x-x-143">Domain-specific Visual Languages for</span>
<span 
class="cmr-17x-x-143">Model-driven Software Engineering</span><br />
<span 
class="cmcsc-10x-x-120"><span 
class="small-caps">a</span> <span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span> <span 
class="small-caps">p</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">s</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">d</span></span><br />
<span 
class="cmcsc-10x-x-120"><span 
class="small-caps">b</span><span 
class="small-caps">y</span></span><br />
<span 
class="cmcsc-10x-x-120">J<span 
class="small-caps">o</span><span 
class="small-caps">h</span><span 
class="small-caps">n</span> C. G<span 
class="small-caps">r</span><span 
class="small-caps">u</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span><span 
class="small-caps">y</span></span><br />
<span 
class="cmcsc-10x-x-120">P<span 
class="small-caps">h</span>D</span><span 
class="cmcsc-10x-x-120"> (1994, U<span 
class="small-caps">n</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">y</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> A<span 
class="small-caps">u</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>),</span><br />
<span 
class="cmcsc-10x-x-120">MS<span 
class="small-caps">c</span></span><span 
class="cmcsc-10x-x-120"> (1991, U<span 
class="small-caps">n</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">y</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> A<span 
class="small-caps">u</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>),</span><br />
<span 
class="cmcsc-10x-x-120">BS<span 
class="small-caps">c</span>(H<span 
class="small-caps">o</span><span 
class="small-caps">n</span><span 
class="small-caps">s</span>)</span><span 
class="cmcsc-10x-x-120"> (1989, U<span 
class="small-caps">n</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">y</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> A<span 
class="small-caps">u</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>)</span><br />
<span 
class="cmcsc-10x-x-120"><span 
class="small-caps">i</span><span 
class="small-caps">n</span> <span 
class="small-caps">f</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span><span 
class="small-caps">f</span><span 
class="small-caps">i</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">m</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">t</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> <span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span> <span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">q</span><span 
class="small-caps">u</span><span 
class="small-caps">i</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">m</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">t</span><span 
class="small-caps">s</span> <span 
class="small-caps">f</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span> <span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span> <span 
class="small-caps">d</span><span 
class="small-caps">e</span><span 
class="small-caps">g</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">e</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span></span><br />
<span 
class="cmcsc-10x-x-120">D<span 
class="small-caps">o</span><span 
class="small-caps">c</span><span 
class="small-caps">t</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> S<span 
class="small-caps">c</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span><span 
class="small-caps">n</span><span 
class="small-caps">c</span><span 
class="small-caps">e</span></span><br />
<span 
class="cmcsc-10x-x-120">U<span 
class="small-caps">n</span><span 
class="small-caps">i</span><span 
class="small-caps">v</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">y</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> A<span 
class="small-caps">u</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>, A<span 
class="small-caps">u</span><span 
class="small-caps">c</span><span 
class="small-caps">k</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span>, N<span 
class="small-caps">e</span><span 
class="small-caps">w</span> Z<span 
class="small-caps">e</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span></span><br />
<span 
class="cmcsc-10x-x-120">A<span 
class="small-caps">u</span><span 
class="small-caps">g</span><span 
class="small-caps">u</span><span 
class="small-caps">s</span><span 
class="small-caps">t</span></span><span 
class="cmcsc-10x-x-120"> 2021</span>
</div>
                                                                                            
                                                                                            
  <h2 class="likechapterHead"><a 
 id="x1-1000"></a>Abstract</h2>
<p><span 
class="cmcsc-10x-x-120">T<span 
class="small-caps">h</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span> <span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">e</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">s</span> <span 
class="small-caps">i</span><span 
class="small-caps">s</span> <span 
class="small-caps">a</span> <span 
class="small-caps">c</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">c</span><span 
class="small-caps">t</span><span 
class="small-caps">i</span><span 
class="small-caps">o</span><span 
class="small-caps">n</span> <span 
class="small-caps">o</span><span 
class="small-caps">f</span> <span 
class="small-caps">m</span><span 
class="small-caps">y</span> <span 
class="small-caps">o</span><span 
class="small-caps">r</span><span 
class="small-caps">i</span><span 
class="small-caps">g</span><span 
class="small-caps">i</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">l</span> <span 
class="small-caps">s</span><span 
class="small-caps">c</span><span 
class="small-caps">h</span><span 
class="small-caps">o</span><span 
class="small-caps">l</span><span 
class="small-caps">a</span><span 
class="small-caps">r</span><span 
class="small-caps">l</span><span 
class="small-caps">y</span> <span 
class="small-caps">w</span><span 
class="small-caps">o</span><span 
class="small-caps">r</span><span 
class="small-caps">k</span><span 
class="small-caps">s</span> </span>published in peer reviewed
journals and conferences. The collection of articles investigate the intersection of the fields of
Domain-Specific Visual Languages (DSVLs) and Model-driven Engineering (MDE). These combined
allow software engineers – and in limited circumstances end users of software systems – to specify
complex software system models at high levels of abstraction (using DSVLs), and then use these
models to generate parts (or even all) of the modelled target software system code, configurations,
user interfaces, data formats, test cases, and/or other implementation-level details (using
MDE).
</p> 
<p>  The first set of articles discuss the development of a range of novel DSVL and MDE supporting
tools. The second set of articles show how these can be used to support software engineers to conduct
requirements engineering and define software architectures for complex software systems. The third
set of articles discuss support for software engineers in designing, implementing and testing software
systems using DSVLs and MDE. The fourth set of articles present DSVL and MDE-based approaches
to supporting software process management. The fifth set of articles present a variety of
“human-centric” and collaborative approaches to supporting these tasks in DSVL-based
tools. The sixth set of articles describe support for DSVL and MDE-based tools targted
to “end users”, allowing these non-technical end users to define and generate their own
software solutions. I conclude with a recent article describing future directions for the
field.
</p> 
<p>
                                                                                            
                                                                                            
</p> 
<p>
                                                                                            
                                                                                            
</p> 
<p>
</p> 
<p>  <span 
class="cmcsc-10x-x-120">F<span 
class="small-caps">o</span><span 
class="small-caps">r</span> J<span 
class="small-caps">u</span><span 
class="small-caps">d</span><span 
class="small-caps">i</span><span 
class="small-caps">t</span><span 
class="small-caps">h</span>, S<span 
class="small-caps">t</span><span 
class="small-caps">e</span><span 
class="small-caps">p</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">i</span><span 
class="small-caps">e</span>, J<span 
class="small-caps">e</span><span 
class="small-caps">s</span><span 
class="small-caps">s</span><span 
class="small-caps">i</span><span 
class="small-caps">c</span><span 
class="small-caps">a</span>, J<span 
class="small-caps">o</span><span 
class="small-caps">s</span><span 
class="small-caps">h</span><span 
class="small-caps">u</span><span 
class="small-caps">a</span>, A<span 
class="small-caps">l</span><span 
class="small-caps">e</span><span 
class="small-caps">x</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span><span 
class="small-caps">e</span><span 
class="small-caps">r</span> <span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">d</span> H<span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">n</span><span 
class="small-caps">a</span><span 
class="small-caps">h</span>.</span>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="likechapterHead"><a 
 id="x1-2000"></a>Acknowledgments</h2>
<p>
</p> 
<p><span 
class="cmcsc-10x-x-120">I <span 
class="small-caps">w</span><span 
class="small-caps">o</span><span 
class="small-caps">u</span><span 
class="small-caps">l</span><span 
class="small-caps">d</span> <span 
class="small-caps">l</span><span 
class="small-caps">i</span><span 
class="small-caps">k</span><span 
class="small-caps">e</span> <span 
class="small-caps">t</span><span 
class="small-caps">o</span> <span 
class="small-caps">g</span><span 
class="small-caps">r</span><span 
class="small-caps">e</span><span 
class="small-caps">a</span><span 
class="small-caps">t</span><span 
class="small-caps">l</span><span 
class="small-caps">y</span> <span 
class="small-caps">t</span><span 
class="small-caps">h</span><span 
class="small-caps">a</span><span 
class="small-caps">n</span><span 
class="small-caps">k</span> </span>my wife Judith for her many years of love for me and support
for my professional work, but also for my family life which gives my work meaning. My children
Stephanie, Jessica, Joshua, Alexander and Hannah I would like to thank for their love and
support, and also their understanding when work demands, especially overseas and interstate
travel, have taken me away from them and sometimes important things happening in their
lives.
</p> 
<p>  Special appreciation goes to my PhD supervisor and mentor Professor John Hosking, who I have
continued to work and co-author with to this day, as evidenced by a number of co-authored works in
this thesis. There are a great many others I would like to thank for their support of my
work and our valuable collaborations. These include, but are certainly not limited to, Rick
Mugridge, Robert Amor, Mohamed Abdelrazek, Iman Avazpour, Amani Ibrahim, Jean-Guy
Schneider, Emilia Mendes, Hourieh Khalajzadeh, Tanjila Kanij, Rashina Hoda, Qiang
He, Yun Yang, Feifei Chen, Norsaremah Salleh, Massila Kamalrudin, Svetha Venkatesh,
Xin Xia, David Lo, Li Li, Scott Barnett, Rajesh Vasa, Ewan Tempero, and many others.
Most of the research I have advanced has been done in collaboration with the great many
students I have been fortunate enough to supervise, including most of the works collected
here.
</p> 
<p>  The significance of this body of work has been recognised by my award of a very prestigious
Australian Research Council Australian Laureate Fellowship in 2019 for the project “Human-centric,
Model-driven Software Engineering” – a direct result of this long programme of work on DSVLs and
MDE. Prior recognition of my research leadership and contributions has included an Alfred Deakin
Professorship (2017), and Fellow of Automated Software Engineering (2012), awarded by the Steering
Committee of the Automated Software Engineering conference, where some of these works included in
the thesis were published.
</p> 
<p>  I would like thank the funding bodies for appreciating and supporting the work I do, including in
particular the Foundation for Research, Science and Technology and the Australian Research Council,
the majority of the works in this thesis supported by these two funders. I greatly appreciate the many
companies I have worked with on a wide range of challenging, interesting and forward-looking R&#x0026;D
projects, several of which are also reported in chapters in this thesis. This includes work with Orion
Health, XSOL, PRISM, CSIRO, CA Labs, Peace Software, Thales, NICTA, Sofismo, and
others.
</p> 
<p>  Finally I thank the many supervisors I have had for supporting my research endeavours, sometimes
when they conflicted with other Department, Faculty and University needs, including Mark Apperley,
John Hosking, Peter Brothers, Michael Davies, Leon Sterling, John Wilson, Peter Hodgson, Jon
Whittle and Ann Nicholson.
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="likechapterHead"><a 
 id="x1-3000"></a>Contents</h2>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  <h2 class="chapterHead"><span class="titlemark">Chapter 1</span><br /><a 
 id="x1-40001"></a>Introduction</h2>
<p>Software engineering depends on models of varying levels of abstraction e.g. software processes,
requirements, architecture, UI and database design, code, test cases etc. Because of their complexity,
software engineers have developed visual representations of these models, as diagrams, over
the past several decades. Many of these diagrammatic visual models are general-purpose
and fit for modelling various aspects of most software systems. Examples include flow
diagrams [<a 
href="#Xbohm1966flow">13</a>], state transition diagrams [<a 
href="#Xparnas1969use">62</a>], entity relationship diagrams [<a 
href="#Xfile1970requirements">21</a>], state charts
[<a 
href="#Xharel1987statecharts">42</a>], data structure diagrams [<a 
href="#Xbachman1969data">9</a>], and various object-oriented modelling languages, such
as the Unified Modelling Language [<a 
href="#Xfowler2004uml">22</a>]. While some of these techniques are limited to
certain aspects of software system modelling, in general they are designed to model “any”
(or most) kinds of software application for any (or most) kinds of software domains of
application.
</p> 
<p>  An alternative approach to these “general purpose” software visual modelling languages is to use
what I term “domain specific visual languages” – or “DSVLs” – models suited to a (sometimes very)
limited domain of software systems and for (sometimes very) limited modelling tasks. These DSVLs
sacrifice generality but have one or more advantages over general purpose modelling languages for this
specific domain. These include using higher levels of abstraction, fitting more closely to the
modeller’s cognitive model of their domain and its software, and/or use of iconic or visual
structures familiar to the modeller in the domain of application. Different DSVLs might be
used by all software engineers or by those working on specific phases of development or in
specific problem domains. They might even be designed for use by non-technical “end users”
of software systems to allow them to – under constrained conditions – model their own
software.
</p> 
<p>  Software models must typically be translated by hand into implementations using programming
language source code and/or other implementation-level artefacts, such as data schema, user interface
elements, business logic and processing code, configuration files, and so on. An alternative approach is
to use “Model-Driven Engineering” – or “MDE” – where a <strong><span 
class="cmbx-12">tool</span></strong> automatically translates one or more
high level models into lower-level models and/or implementation-level artefacts. Advantages of such
MDE approaches can include much faster software implementation, improved quality of software,
enabling less technically proficient developers to realise solutions, and even allowing end users to
model and build their own software solutions [<a 
href="#Xschmidt2006model">66</a>]. MDE may use general-purpose models, textual
domain-specific languages, or models created and visualised with domain-specific visual
languages.
</p> 
<p>  This thesis summarises my efforts over many years to develop domain-specific visual language
(DSVL) for software engineering models and associated model-driven engineering (MDE) tools to turn
these models into software solutions.
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.1   </span> <a 
 id="x1-50001.1"></a>Visual Modelling Languages in Software Engineering</h3>
<p>Visual Languages have been used for thousands of years to communicate complex ideas, or “models”
of the world. They use a range of human capabilities and allow complex models to be
presented and manipulated using metaphors close to a user’s cognitive models. The idea is to
provide a way to visualise and/or author complex models using human visual capabilities,
compared to textual representations [<a 
href="#Xmyers1990taxonomies">60</a>, <a 
href="#Xshu1988visual">68</a>, <a 
href="#XMoody2009">59</a>]. These include but are not limited to boxes
and lines, information containment, colour and shading, formal or informal annotations,
sketched or computer-constructed diagrams, iconic representations, and textual labels
[<a 
href="#Xblackwell2001pictorial">12</a>, <a 
href="#XMoody2009">59</a>].
</p> 
<p>  Software Engineering has depended on using visual models to represent complex software system
characteristics even before software engineering as a discipline in its own right began [<a 
href="#XMoody2009">59</a>, <a 
href="#Xludewig2003models">55</a>]. Even a
non-trivial software system is made up of many concepts, ranging from high level requirements
                                                                                            
                                                                                            
describing the problem space; architectural abstractions describing both software and hardware
components in the solution space; design-level data, interface, processing logic and other information
about decisions made about implementing the software; various information about testing and
deployment; and are often used to aid in software process implementation and project management.
Such visual models can be constructed manually to aid development, might be reverse-engineered
from existing code and other implemented system artefacts, or might be generated from other, higher
level models [<a 
href="#Xschmidt2006model">66</a>, <a 
href="#Xalmorsy2014horuscml">6</a>].
</p> 
<p>  As software systems have grown ever more complex, new general-purpose visual modelling
techniques have been developed to help software engineers to manage this complexity and model a
very diverse range of systems. Entity-relationship diagrams are still a very commonly used approach
to describe database structures [<a 
href="#Xfile1970requirements">21</a>]. Various forms of state transition diagrams and state charts model
how software system state changes over time [<a 
href="#Xparnas1969use">62</a>, <a 
href="#Xharel1987statecharts">42</a>]. The Business Process Modelling Language
(BPML) [<a 
href="#Xthiagarajan2002bpml">70</a>] has been widely used to model general business processes, technical implementations of
such processes as services, and service communication. The Unified Modelling Language (UML)
[<a 
href="#Xfowler2004uml">22</a>] has been used to model software requirements, system designs, software designs, and
various specialised aspects of systems. Computer Aided Design (CAD) tools have been
deployed in many engineering domains and many share common representations of models
[<a 
href="#Xhenderson1999line">43</a>].
</p> 
<p>  Key advantages of such general purpose visual modelling approaches include: </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>standardised modelling constructs, semantics and notations;
      </p> 
</li>
      <li class="itemize">
      <p>notations familiar to a wide range of users in the general domain;
      </p> 
</li>
      <li class="itemize">
      <p>2D  (and  sometimes  3D)  layouts  and  visual  elements  allowing  wide  range  of  model
      representations;
      </p> 
</li>
      <li class="itemize">
      <p>tool support to build models, reverse engineer models from code, and support aspects of
      model-driven engineering; and
      </p> 
</li>
      <li class="itemize">
      <p>useful for solving problems in a very wide variety of application domains.</p> 
</li></ul>
<p>
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.2   </span> <a 
 id="x1-60001.2"></a>Domain-Specific Visual Languages in Software Engineering</h3>
<p>Such general-purpose modelling languages are not always the best choice to use to model a
software system. They do not leverage particular domain-specific concepts, leading often to
overly-complex models, cluttered visual formalisms, hard-to-read and hard-to-maintain diagrams
[<a 
href="#Xcox1989prograph">17</a>, <a 
href="#Xshneiderman19931">67</a>, <a 
href="#Xwhitley1997visual">72</a>, <a 
href="#Xgrundy2012generating">37</a>]. These problems are caused by using modelling and notational concepts
designed for a very wide range of purposes. In order to describe a problem in a target
domain, a large number of general-purpose abstractions may need to be assembled. No
domain-specific concepts are built into the modelling language and hence models need to be
composed to describe them. General purpose visual notations similarly need to be composed
                                                                                            
                                                                                            
or augmented in often cumbersome ways to express domain-specific concepts e.g. with
UML profiles and BPMN annotations. Usability can become a major problem of both the
general purpose visual notation and its supporting tools [<a 
href="#XMoody2009">59</a>, <a 
href="#Xagarwal2003object">1</a>, <a 
href="#Xpetre2013uml">64</a>]. Even domain-specific
extensions to the general purpose modelling language, such as UML profiles and BPMN
annotations, do not solve these issues, and often further complicate the visual models used
[<a 
href="#Xplanas2020uml">65</a>, <a 
href="#Xpetre2013uml">64</a>, <a 
href="#Xchaudron2012effective">14</a>].
</p> 
<p>  Domain-specific Visual Languages (DSVLs) provide a powerful, human-centric approach to
presenting and manipulating complex information [<a 
href="#Xmernik2005and">58</a>, <a 
href="#Xguerra2009supporting">41</a>, <a 
href="#Xesser2001framework">20</a>, <a 
href="#Xledeczi2001composing">51</a>, <a 
href="#Xsprinkle2004domain">69</a>]. DSVLs are designed for use in
a specific domain with a domain-specific set of modelling concepts and a domain-specific set
of visual notational elements [<a 
href="#Xmernik2005and">58</a>, <a 
href="#Xledeczi2001composing">51</a>]. As domain concepts are built into the language,
modelling problems in the domain – for which the DSVL is targeted – typically requires
much smaller models and visual notational elements. Ideally the DSVL visual notation
leverages both concepts and representations – “visual metaphors” – from its target domain of
use. This makes the DSVL both more efficient for modelling in the target domain, but
also better suits its target end users’ modelling needs than a general purpose modelling
language.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.2.1   </span> <a 
 id="x1-70001.2.1"></a>What are DSVLs?</h4>
<p>There is no specific, generally accepted definition for a “DSVL”. In fact, they go by a variety of names
e.g. visual domain-specific language, domain-specific visual modelling language, or domain-specific
visual model. I define a Domain-specific Visual Language (DSVL) – for the purpose of
this thesis and based on a definition John Hosking and I devised many years ago – to be:
<br 
class="newline" /><br 
class="newline" /><em><span 
class="cmti-12">“a visual modelling language where the model and notation are customised for a particular problem</span>
<span 
class="cmti-12">domain”</span></em> <br 
class="newline" /><br 
class="newline" />
</p> 
<p>  In DSVLs we make a trade off between generality of the language – i.e. the range of
problems that are able to be solved – and terseness of notation and closeness of mapping
to the target problem domain – i.e. how specialised the visual notation is for use in a
particular domain. By this I mean that we have a specialised visual modelling language
only suitable for use in specific application domains, <strong><span 
class="cmbx-12">but which is optimised for these</span>
<span 
class="cmbx-12">domains</span></strong>.
</p> 
<p>  The critical features of a DSVL are thus: </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>an underlying model – or “meta-model” – with constructs for modelling only within the
      target domain, not very general problem domains;
      </p> 
</li>
      <li class="itemize">
      <p>visual notations ideally familiar to the DSVL target users in the specific target domain;
      </p> 
</li>
      <li class="itemize">
      <p>the use of visual metaphors specific to the target domain;
      </p> 
</li>
      <li class="itemize">
                                                                                            
                                                                                            
      <p>only useful (usually) for solving problems in the target domain; and
      </p> 
</li>
      <li class="itemize">
      <p>sometimes is an existing, preferred modelling language for its users in the target domain.</p> 
</li></ul>
<p>  To give tangible examples of such DSVLs, I briefly review a few below, with their key features,
advantages – and some key limitations. Enterprise Modelling Language [<a 
href="#Xli2014visual">52</a>], Horus-HPC [<a 
href="#Xalmorsy2015supporting">3</a>] and
Statistical Design Language [<a 
href="#Xkim2005suite">50</a>] are described in detailed chapters of their own later in this
thesis.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/EML-1.png" alt="PIC"  
width="459" height="459"  /><a 
 id="x1-7001r1"></a>
<a 
 id="x1-7002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.1: </span></span><span  
class="content"><span 
class="cmss-10">Enterprise Modelling Language (EML) showing a student enrolment process (from [</span><a 
href="#Xli2014visual"><span 
class="cmss-10">52</span></a><span 
class="cmss-10">]).</span>           </span></figcaption><!--tex4ht:label?: x1-7001r1.2.1 -->
                                                                                            
                                                                                            
  </figure>
  <h5 class="subsubsectionHead"><a 
 id="x1-8000"></a>Enterprise Modelling Language (EML)</h5>
<p>EML (Enterprise Modelling Language) is a DSVL that we invented for modelling business processes
and process structures [<a 
href="#Xli2014visual">52</a>]. It uses a novel tree-based metaphor to structure services within an
organisation into a hierarchical form, similar to that used to group organisational structures. A
novel overlay metaphor is used to describe process flow, linking services in the hierarchy
together to form the process flow. Multiple overlays correspond to different processes.
Process branching can be visualised by diverging or converging overlaps. Exceptions and
error handling can be described with specialised overlays. A supporting tool, EMLTool
[<a 
href="#Xli2014visual">52</a>], provides an authoring tool with novel fish-eye viewer and other large-scale DSVL
support.
</p> 
<p>  Figure 1.1  shows a student enrolment system’s key services and processes modelled in EML. This
example shows a tree structure being used to represent different components and work tasks
implemented as discrete services in a student management system, overlaid with multiple
“process flows”. The tool, EMLTool, allows users to show and hide different process overlays,
break large enterprise service hierarchies into multiple views, and provides large scale
service representation via fish-eye views and alternative views of processes using a subset of
BPML. Business Process Execution Language for Web Services (BPEL4WS) scripts are
generated from the EML models to be “run” by a BPEL-based workflow management
system.
</p> 
<p>  EML does not support general software application modelling and only a subset of service
orchestration. It is oriented towards knowledgeable domain experts who are non-technical uses of
complex service-oriented applications and want and need the power to configure new process flows
using pre-implemented and hosted services. While EML supports flexible and scalable modelling of
these services, services themselves can not be built, only aggregations and orchestrations. No data
storage and user interface capabilities for the services are provided by EML itself. The
tree-and-overlay metaphor is natural for these target end users but may be frustrating or
counter-intuitive to others, including service implementers.
</p> 
<p>
  </p> 

  <h5 class="subsubsectionHead"><a 
 id="x1-9000"></a>Horus-HPC</h5>
<p>Horus-HPC (High Performance Computing) is a web-based IDE for developing parallel
programs for complex scientific tasks to be run on GPUs, CPU grids or cloud computing
platforms [<a 
href="#Xalmorsy2015supporting">3</a>]. The target end user is a scientific programmer who is knowledgeable about the
target scientific problem domain; has some coding skills; and some limited HPC design and
development skills. The idea is to use a set of DSVLs at differing levels of abstraction to
model target problem domain (e.g. molecular simulation or pulsar discovery algorithms),
including scientific formulae; model sequential solutions; model - with the help of packaged
patterns - HPC parallelised solutions; describe deployment onto a target HPC platform; and
generate parts of a C or GPU kernel program code implementation; and then complete this
code by hand. The tool is not designed for complete code or script generation but to be
a quality and productivity improvement support platform. The DSVLs have the added
advantage that the higher level ones are aimed at mirroring how scientific end users actually
describe problems in their domain using whiteboards, formulae, pseudo-code, schematics
etc.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/Horus-1.png" alt="PIC"  
width="459" height="227"  /><a 
 id="x1-9001r2"></a>
<a 
 id="x1-9002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.2: </span></span><span  
class="content"><span 
class="cmss-10">Horus-HPC being used to model a parallel program (from [</span><a 
href="#Xalmorsy2015supporting"><span 
class="cmss-10">3</span></a><span 
class="cmss-10">]).</span>                                </span></figcaption><!--tex4ht:label?: x1-9001r -->
                                                                                            
                                                                                            
  </figure>
<p>  Figure 1.2  shows an example of three Horus-HPC diagrams modelling a parallel program. The left
hand side diagram shows a high level box-and-line representation of key HPC program components
wired together. The top right formulae editor allows scientists to model mathematical aspects of their
problems at a high level and link these abstractions both to box-and-line component realisations and
code implementations of (parts of) their scientific problem. The C code editor in the bottom right
shows a generated program from the component diagram with user additions of code. The message
passing (OpenMPI) or GPU (OpenCL) code is generated from lower-level component diagrams that
map the algorithm components onto HPC hardware implementation components for the
chose implementation platform. Further views include data visualisation and modelling to
show results of complex calculations as charts, scatter plots, etc, and to model complex
input and output data formats used to produce the generated C code implementation data
structures.
</p> 
<p>  While Horus-HPC provides a fully-fledged, cloud-based development environment for a very wide
range of HPC applications and HPC hardware platforms, removing the 3GL C code editor
from the IDE leaves it with special purpose modelling views that are not general purpose.
These have been designed for scientist-programmers to model several levels of abstractions
of their HPC programs. While their models allow us to generate significant amounts of
HPC C code, they do not generate full implementations without direct textual C code
editing.
  </p> 

  <h5 class="subsubsectionHead"><a 
 id="x1-10000"></a>Statistical Survey Design Language (SDL)</h5>
  <figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/SDL-1.png" alt="PIC"  
width="459" height="459"  /><a 
 id="x1-10001r3"></a>
<a 
 id="x1-10002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.3: </span></span><span  
class="content"><span 
class="cmss-10">Statistical Design Language (SDL) being used to model (a) survey tasks; (b) survey sampling techniques;</span>
<span 
class="cmss-10">(c) an analytical technique; and (d) links between diagrams (from [</span><a 
href="#Xkim2005suite"><span 
class="cmss-10">50</span></a><span 
class="cmss-10">]).</span>                                   </span></figcaption><!--tex4ht:label?: x1-10001r -->
                                                                                            
                                                                                            
  </figure>
<p>  SDL (Statistical Design Language) is a DSVL that we invented for designing and enacting
statistical surveys. It provides a suite of related visual modelling languages addressing different
aspects of statistical survey design and implementation using the R statistical analysis tool [<a 
href="#Xkim2005suite">50</a>].
Survey diagrams are used to represent a high level view of a survey including purpose, key population
sources and key outcomes. Survey data diagrams are used to model the datasets used in the surveying
including data sourcing and management. Task diagrams are used to model the key steps
involved in running the survey including pre-survey activities and post-survey activities.
Technique diagrams are used to model low-level statistical techniques to analyse parts of the
survey data. Technique diagrams are used to generate R scripts and web services providing
remote access to the encapsulated scripts. Services cane be orchestrated to realise the
surveying.
</p> 
<p>  Figure 1.3  shows an example of three SDL diagrams modelling a NZ Crime Victimisation
Survey (from [<a 
href="#Xkim2005suite">50</a>]). After creating the overall survey structure a statistician creates SDL
views to specify the survey process and techniques to use in detail. Figure 1.3  (a) shows
a hierarchical task diagram, specifying two data analysis tasks to be carried out on the
survey data. During data collection, the main concern is to specify sampling techniques
used in the survey process and types of statistical metadata related to collected data.
Figure 1.3  (b) specifies the two sampling methods to be used in the survey. Here the
sampling frame is stratified in two stages by the modified area unit (1) then household
visits planned using patterned clustering (2). Data Frame and Sample data icons indicate
data used in pre-testing and collection phases. Figure 1.3  (c) shows a survey technique
diagram describing the data analysis operations implementing the tasks in Figure 1.3
(a). Two visualisation methods (boxplot and multivariate analysis) are used to assess
whether there is evidence of a statistical association between data variables. It generates
textual R script implementations of aggregate techniques and uses R scripts to implement
its low-level technique components. Figure 1.3  (d) shows links between diagrams and
artefacts.
</p> 
<p>  SDL provides a powerful range of multi-level abstractions for statistical survey designers,
statisticians being the target end users. This includes high level design, data specification, process
flow, low-level statistical techniques, and a wide range of visualisations to show survey data analysis
results. SDLTool also provides capabilities to generate reusable aggregate services that implement
complex processes and techniques for reuse by other service-oriented applications. However, SDL can
not express general purpose programming concepts and constructs and nor is it designed for general
purpose business intelligence applications.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.2.2   </span> <a 
 id="x1-110001.2.2"></a>Why use DSVLs</h4>
<p>Sometimes it is not obvious that a DVSL-based solution either exists or is necessarily a better
solution than a textual Domain-Specific Language (DSL) or a general purpose modelling approach or
programming language. Some indicators I have found useful when exploring the use of DSVLs for
application to a new domain are outlined below. DSVLs are a useful modelling approach in situations
where:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>a domain has a set of domain-specific concepts capturing rich properties about the domain
      that lend themselves to being captured in a meta-model;
      </p> 
</li>
                                                                                            
                                                                                            
      <li class="itemize">
      <p>experts in the target domain have a set of notations or representations of the domain
      concepts they regularly use to describe aspects of the domain in designs, meetings, to
      explain models etc;
      </p> 
</li>
      <li class="itemize">
      <p>models describing solutions in the domain can be readily constructed from these notations
      and underlying concepts far more readily and efficiently that if using more general purpose
      modelling languages and tools;
      </p> 
</li>
      <li class="itemize">
      <p>domain-specific models can be used to synthesize general models e.g. code or parts of
      general models to realise solutions
      </p> 
</li>
      <li class="itemize">
      <p>target end users find the domain specific modelling concepts, notations, tool support for
      authoring the models and support for generating solutions (or partial solutions) from
      the models more effective and efficient than using general-purpose modelling tools and
      approaches.</p> 
</li></ul>
<p>  A good indication of a DSVL being potentially useful is when talking with software engineers or
target end users – and/or visiting their work spaces or observing them interacting in meetings – a set
of informal DSVLs and their related domain-specific concepts are frequently used. Business process
designers and indeed many business process improvement activities for many years have adopted
BPMN and EML-style modelling constructs to design how the processes work, who enacts them, and
related artefacts and data.
</p> 
<p>  If a domain has a set of limited concepts that naturally provide an abstract description of a
solution in that domain, this can be indicative of potential for DSVL (or DSL or combination)
solution. These concepts are limited in scope i.e. are domain-specific, but provide powerful constructs
for expressing complex ideas simply, consistent and elegantly. For example, the process stage, process
flow, split flow, join, flow, actor and artefact concepts in business process modelling provide a very
powerful, simple metaphor for describing a wide range of solutions. This leads to DSVLs like EML
being able to model complex business process problems far more quickly and accurately and usefully
than general-purpose approaches. The statistical surveying domain does not have an agreed
DSVL or set of DSVLs, but we identified when talking with statisticians it does have
well-defined concepts that we were able to map to SDL model concepts. From this we
developed a set of DSVL elements to represent these domain-specific concepts and their
inter-relationships.
</p> 
<p>  While 3GL computer programming languages are very flexible and powerful, and it may
be argued APIs and libraries provide sets of packaged abstractions for sub-domains, key
disadvantages are the time it takes to construct solutions, repetitiveness, and lack of higher
level abstractions than code constructs. DSVLs describing higher level domain elements
can be enriched with properties to enable generation of whole or part 3GL programming
language solutions. Enrichment may also be by relating one DSVL element to another e.g. a
Horus-HPC parallel computation element in one view to a GPU grid compute element in
another view, indicating how OpenCL kernel code is to be generated from the combined
model.
</p> 
<p>
  </p> 

                                                                                            
                                                                                            
  <h4 class="subsectionHead"><span class="titlemark">1.2.3   </span> <a 
 id="x1-120001.2.3"></a>Designing DSVLs</h4>
<p>DSVL meta-models can be designed using conventional conceptual and data modelling techniques
[<a 
href="#Xledeczi2001composing">51</a>, <a 
href="#Xesser2001framework">20</a>]. Design concepts are identified from various information sources: domain experts; existing
partial models (whether on paper or computer); existing 3GL or DSL solutions where meta-model
elements and relationships are abstracted; or from databases, CSV and XML files, or other domain
artefacts that capture part of the necessary modelling constructs for the domain. Often other
solutions exist for the target domain, even DSVL based solutions, that provide most if not all of the
information needed to define and construct the necessary meta-model for the new DSVL based
solution [<a 
href="#Xesser2001framework">20</a>].
</p> 
<p>  For example, Horus-HPC’s low-level models and parallel programming patterns are derived from
the large body of work in this area over many years. However, its high level models we had to define
after considerable work with scientists who develop their own bespoke HPC solutions for different
domains [<a 
href="#Xalmorsy2015supporting">3</a>]. EML uses BPMN and earlier business process modelling tool meta-model constructs to
describe its overlay processes. SDL provides ways to package R scripts for reuse related to survey
implementation, and structure data definitions and higher level survey process tasks and
goals.
</p> 
<p>  The most challenging – and often most creative – aspect of DSVL based solution design
are the visual notations that provide much of the power and advantage of DSVL-based
solutions [<a 
href="#XMoody2009">59</a>]. A range of drivers influence how the visual notation is designed and how
the overall solution will appear to target end users. These include but are not limited
to:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>Who  are  the  target  end  users  of  the  DSVL?  Are  they  familiar  with  visual  oriented
      modelling approaches and support tools? Are they technically knowledgeable software
      engineers or non-technical domain experts or potentially both?
      </p> 
</li>
      <li class="itemize">
      <p>What size and complexity of model will need to be represented?
      </p> 
</li>
      <li class="itemize">
      <p>How big and complex will the resultant DSVL-based models get?
      </p> 
</li>
      <li class="itemize">
      <p>if multiple DSVLs will be used to represent the problem domain, how do we link parts
      together across diagrams?
      </p> 
</li>
      <li class="itemize">
      <p>What visual metaphors do the target end users work with now? Can we reuse and build
      on these in some way so the proposed DSVL-based solution will look familiar to them?
      </p> 
</li>
      <li class="itemize">
      <p>Will DSVL models need to be shared amoung many people, live for a long time, be
      modified extensively during their useful lifespan?
      </p> 
</li>
      <li class="itemize">
      <p>Are there any existing DSVLs used for different problem domains that might translate
      well to the one under consideration? Can we learn from the successes (or failures) of these
      DSVLs in those other domains?</p> 
</li></ul>
                                                                                            
                                                                                            
<p>  Practical considerations also need to be taken into account. Can the intended implementation
platform for the DSVL tool actually support the range and complexity of the visual notations? Are
the target end users going to be able to effectively and efficiently understand and use both the
notations themselves and their editing tools? How do we handle challenges like version control,
configuration management and collaborative editing of DSVL-based representations? Is the
DSVL-based solution really better than using a conventional general purpose 3GL programming
language (C, Java, Python etc), scripting language (R, Matlab, Perl etc). Is a special purpose DSL
(textual) language more useful than a visual form?
</p> 
<p>  These approaches are not always incompatible e.g. EMLTool supports both the EML DSVL and
general purpose BPML; Horus-HPC includes a fully functional C code editor and extensive API
library; and including components and scripts implemented in textual R code is supported by
SDLTool.
</p> 
<p>  Users of DSVL-based modelling solutions can be software developers e.g. HorusHPC,
domain experts e.g. statisticians for SDL and business process experts for EML.Sometimes
multiple user groups can be supported by the same tool/DSVL or subsets of the DSVL.
Scientists can specify high level physical model principles in HorusHPC formula views
and software developers translate these into detailed parallel code level DSVLs. Survey
designers can specify goals and high level process tasks in SDL process diagrams, and
expert statisticians and data scientists specify statistical technique details in Technique
diagrams.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.2.4   </span> <a 
 id="x1-130001.2.4"></a>Realising DSVL-based Applications</h4>
<p>Once a DSVL has been designed for a target domain we need to build a tool that supports the use of
this DSVL. Given the complexity of such a task, a number of platforms have been developed to aid
the creation of DSVL-based tools e.g. MetaEDIT+ [<a 
href="#Xtolvanen2003metaedit+">71</a>], Eclipse GMF [<a 
href="#Xgronback2009eclipse">24</a>] and Microsoft DSL tools
[<a 
href="#Xcook2007domain">16</a>]. As can be seen from the representative DSVLs and their supporting tools in this chapter, a
wide range of considerations need to be taken into account when building such a tool
[<a 
href="#Xpelechano2006building">63</a>]:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>How large and complex with the DSVL tool likely be - how many DSVL diagram types,
      elements, and other features like code generation, data import or export, data visualisation
      etc? Different platforms provide different ranges of solutions.
      </p> 
</li>
      <li class="itemize">
      <p>Can the tool platform handle the range of visual abstractions, appearances, composites
      and intended editing operations and interactions?
      </p> 
</li>
      <li class="itemize">
      <p>Will complex data or code or scripts need to be imported? Generated and exported? Does
      the tool platform have the necessary capabilities?
      </p> 
</li>
      <li class="itemize">
      <p>Will the tool interface need to be provided through a web browser or mobile phone?
      </p> 
</li>
      <li class="itemize">
                                                                                            
                                                                                            
      <p>Are there approaches provided to supporting DSVL versioning, diffing, shared editing,
      large scale rendering etc?
      </p> 
</li>
      <li class="itemize">
      <p>Will the DSVL-based tool need to be integrated closely with other tools / applications,
      and is there support for such integration in the DSVL tool platform?
      </p> 
</li>
      <li class="itemize">
      <p>Can we impose various necessary constraints, checks and design critics on the DSVLs
      using the DSVL tool, in order to ensure models are correct, consistent and complete?</p> 
</li></ul>
<p>  One of my main contributions over many years to making DSVL concepts realisable is the
development of numerous supporting tools, both for the DSVL modelling and associated MDE-based
support. These include but are not limited to MViews [<a 
href="#Xgrundy1996constructing">38</a>], JViews [<a 
href="#Xgrundy2002developing">27</a>], JComposer [<a 
href="#Xgrundy2000constructing">35</a>], Pounamu
[<a 
href="#Xzhu2007pounamu">73</a>], Marama [<a 
href="#Xgrundy2012generating">37</a>], VikiBuilder [<a 
href="#Xhirsch2010vikibuilder">44</a>], and Horus [<a 
href="#Xalmorsy2015supporting">3</a>].
</p> 
<p>  When developing prototype DSVLs and their support tools for research and practice, we want to
evaluate both the support tool and its DSVL solution using a range of criteria [<a 
href="#XMoody2009">59</a>, <a 
href="#Xgreen1996usability">23</a>]. Learning from
the results of these evaluations, we may want to refine the DSVL and/or its support tool to
address issues our target end users have encountered and reported to us or that we have
observed.
</p> 
<p>
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.3   </span> <a 
 id="x1-140001.3"></a>Model-Driven Engineering of Software</h3>
<p>Doug Schmidt in a widely read introduction to a COMPUTER special issue on Model-driven
Engineering describes MDE as: <br 
class="newline" /><br 
class="newline" /><em><span 
class="cmti-12">“Model-driven engineering technologies offer a promising approach to address the inability of</span>
<span 
class="cmti-12">third-generation languages to alleviate the complexity of platforms and express domain concepts</span>
<span 
class="cmti-12">effectively. ”</span></em> [<a 
href="#Xschmidt2006model">66</a>] <br 
class="newline" /><br 
class="newline" />
</p> 
<p>  Similarly to some of the drivers behind Domain-Specific Visual Languages choice in some
domains, MDE approaches to software engineering attempt to address long standing issues
including:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>textual  programming  languages  (“3GLs”)  are  often  too  low-level  to  describe  many
      abstractions in software engineering
      </p> 
</li>
      <li class="itemize">
      <p>SE models are often too disconnected from 3GLs (program code) e.g. traditional analysis
      and design languages
      </p> 
</li>
      <li class="itemize">
      <p>we often need high-level modelling languages to better express requirements, architectures,
      designs, tests etc through software engineering processes
      </p> 
</li>
                                                                                            
                                                                                            
      <li class="itemize">
      <p>such SE models can be used to “construct” software directly i.e. translate from design-level
      elements to code-level elements via a “model transformation” approach – these models at
      various levels of abstraction can still be directly turned into/related to code constructs
      </p> 
</li>
      <li class="itemize">
      <p>to do this we need to provide ways to build models, reason with models, translate models
      to(/from) code</p> 
</li></ul>
<p>  Note that working with textual 3GL code is often still very useful/necessary even in systems where
a lot of model-driven development support is used. Similarly, textual Domain-specific Languages
(DSLs) can be used with visual DSVL models in domains where textual representations are more
useful some of the time.
</p> 
<p>  Many early MDE approaches originally focused on code generation. Increasingly, rather than
generating just code from models, scripts or configurations or even other models are generated. For
example, SDLTool generates R scripts from its survey technique diagrams, some of which
may contain prepacked R script function calls themselves. EML generates BPEL4WS
(Business Process Execution Language 4 Web Services) models that themselves can be
run (enacted) via a workflow engine to orchestrate business process-implementing web
services.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/rappt1.png" alt="PIC"  
width="362" height="362"  /><a 
 id="x1-14001r4"></a>
<a 
 id="x1-14002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.4: </span></span><span  
class="content"><span 
class="cmss-10">Example of MDE-based textual app model to android model to code generation process in RAPPT</span>
<span 
class="cmss-10">(from [</span><a 
href="#Xbarnett2015bootstrapping"><span 
class="cmss-10">11</span></a><span 
class="cmss-10">])</span>                                                                                   </span></figcaption><!--tex4ht:label?: x1-14001r1.3 -->
                                                                                            
                                                                                            
  </figure>
<p>  An example of such model-driven engineering from a textual Domain Specific Language is RAPPT
[<a 
href="#Xbarnett2015bootstrapping">11</a>]. Figure 1.4  outlines its process. RAPPT takes a textual design-level mobile App Description –
sometimes called a Platform Independent Model (PIM) (it can also take a DSVL that represents
limited, high-level parts of the textual app model). It has a model transformer that transforms this
abstract design-level PIM App Description into a much more detailed code- and API-level Android
Model for the Android platform mobile apps – sometimes called a Platform Specific Model (PSM). It
then uses a further Code Generator component to translate the Android Model combined with a set
of Code Templates into Android mobile app implementation artefacts – source code but also scripts,
manifest, directories, XML and iconic elements. These can then be built by an Android
development environment to implement the modelled mobile app. RAPPT allows generated
Android code to be edited by the developer to add further features not supported by its code
generated or to refine the skeleton mobile app implementation into a fully-fledged app
product.
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.4   </span> <a 
 id="x1-150001.4"></a>DSVLs and MDE for Software Engineering</h3>
<p>Bringing these two approaches together – modelling complex software systems with DSVLs and using
these DSVL-visualised models in MDE processes — has been a key focus of a large part of my
research work to date. Key requirements for such a combined approach, as outlined in Figure 1.5 ,
include:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>a set of domain meta-model(s), model instances are used to model the problem domain;
      </p> 
</li>
      <li class="itemize">
      <p>a set of visualisation(s) of these domain model instances — textual and graphical – allow
      software engineers and/or end users to construct and refine problem domain solutions;
      </p> 
</li>
      <li class="itemize">
      <p>mappings between models allow a tool to transform higher level models to lower level
      ones, including to code, scripts, XML etc.;
      </p> 
</li>
      <li class="itemize">
      <p>a high level model might be transformed into a lower level model e.g. a requirements-level
      problem space model to a design-level solution space model, or a platform independent
      model enriched to become a more detailed platform specific model;
      </p> 
</li>
      <li class="itemize">
      <p>low-level models are transformed to implementation-level code, scripts, configurations,
      etc that can be compiled to implement the system, or may be interpreted by an engine
      to realise the software desired;
      </p> 
</li>
      <li class="itemize">
      <p>editing tools for DSVL-based model visualisations;
      </p> 
</li>
      <li class="itemize">
                                                                                            
                                                                                            
      <p>transformation support i.e. model-¿model, model -¿ code transformers;
      </p> 
</li>
      <li class="itemize">
      <p>visualisation support of models is sometimes useful e.g. code/data -¿ model -¿ DSVL
      represenation;
      </p> 
</li>
      <li class="itemize">
      <p>reasoning support e.g. analysis of models — completeness, correctness, consistency; and
      </p> 
</li>
      <li class="itemize">
      <p>model  management  support  e.g.  version  control,  diffing/merging,  team  collaboration
      support etc.</p> 
</li></ul>
  <figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/dsvls_mde.png" alt="PIC"  
width="290" height="290"  /> <a 
 id="x1-15001r5"></a>
<a 
 id="x1-15002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.5: </span></span><span  
class="content"><span 
class="cmss-10">Outline of the DSVLs + MDE engineering process</span>                                          </span></figcaption><!--tex4ht:label?: x1-15001r1.4 -->
                                                                                            
                                                                                            
  </figure>
<p>  To illustrate the variety of ways this DSVL+MDE approach can be used, in the following
subsections I illustrate a few example DSVL+MDE tools from my work. Some of these are targeted at
supporting software engineers performing specific tasks. Some are targeted at supporting domain
experts (non-technical end users). For each example I outline its problem domain; target user
group(s); key meta-model elements; DSVL(s) used; transformation approach used; and target
generated artefacts.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.4.1   </span> <a 
 id="x1-160001.4.1"></a>Performance Test-bed Generation Tools</h4>
  <figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/maramamte.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-16001r6"></a>
<a 
 id="x1-16002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.6: </span></span><span  
class="content"><span 
class="cmss-10">Example of the MaramaMTE performance testbed generator in use (from [</span><a 
href="#Xdraheim2006realistic"><span 
class="cmss-10">19</span></a><span 
class="cmss-10">])</span>                   </span></figcaption><!--tex4ht:label?: x1-16001r1.4.1 -->
                                                                                            
                                                                                            
  </figure>
<p>  I have led research into numerous performance engineering tools using DSVLs and MDE
approaches. The initial ideas for this line of research came from my time in industry in the 1980s
where I had to try and improve performance of complex database systems. This required writing
many testing scripts – or “performance test-beds” – that was very tedious work. However,
many of these test-bed scripts had great similarities and if a high level model of the target
system structure could be defined, much if not all the performance testing scripts could be
automatically generated from these models. Figure 1.6  shows one such tool in use, MaramaMTE
[<a 
href="#Xdraheim2006realistic">19</a>].
</p> 
<p>  MaramaMTE has the following key features:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>Problem  domain:  generation  of  performance  test  bed  code/scripts  from  high  level
      modelling of software architectures of distributed systems
      </p> 
</li>
      <li class="itemize">
      <p>Target  user  group(s):  performance  engineers  (typically  highly  experienced  software
      engineers)
      </p> 
</li>
      <li class="itemize">
      <p>Key meta-model elements: architectural elements of distributed systems – clients, servers,
      databases,  network  connections,  compute  and  data  applications  ;  loading  models  for
      clients e.g. number users, number transactions per second, types of transactions etc
      </p> 
</li>
      <li class="itemize">
      <p>DSVL(s)  used:  (1)  architecture  model  with  detailed  characteristics  of  each  element
      (representing  key  software  components);  and  (2)  stochastic  form  charts  (representing
      probabilistic client loading models)
      </p> 
</li>
      <li class="itemize">
      <p>Transformation approach used: XSLT scripts and Java code
      </p> 
</li>
      <li class="itemize">
      <p>Target generated artefacts: client, server code, loading scripts, build scripts, deployment
      scripts</p> 
</li></ul>
<p>  When using MaramaMTE, the performance engineer models their system’s software architecture
using architectural view DSVLs, as shown in Figure 1.6  (1). They model client loading models using
stochastic form charts, as shown in Figure 1.6  (2). The XSLT-based code generators synthesize from
these two DSVL models scripts e.g. for Apache JRunner (3) and Java client and server code e.g.
Figure 1.6  (4). MaramaMTE generates real code that is compiled and run for clients
and servers. The loading scripts have the clients run a very large number of transactions
against the servers and MaramaMTE collects results for presentation to the performance
engineers.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.4.2   </span> <a 
 id="x1-170001.4.2"></a>Data Transformation Tools</h4>
<p>Integrating complex distributed systems by exchanging complex data is a very common need in many
systems. Originally Electronic Data Interchange messages were used and the writing of EDI encoding
                                                                                            
                                                                                            
and decoding software to support EDI message exchange between systems is a very challenging task.
We developed a tool with Orion Health in a collaborative R&#x0026;D project to facilitate the modelling of
complex EDI messages for health system data exchange, the Orion Message Mapper [<a 
href="#Xgrundy2001generating">34</a>],
eventually commercialised as the Raphsody message mapping engine suite. This approach used
hierarchical tree-based message mappings to specify correspondences between source EDI
message elements and target EDI message elements, and formulae to translate source
data to target data formats. While suitable for software engineers to use, the original
target users of Orion Message Mapper, they are not very suitable for non-technical domain
experts.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/formmapper.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-17001r7"></a>
<a 
 id="x1-17002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.7: </span></span><span  
class="content"><span 
class="cmss-10">Example of the Form-based mapping generator in use (from [</span><a 
href="#Xli2002data"><span 
class="cmss-10">53</span></a><span 
class="cmss-10">])</span>                              </span></figcaption><!--tex4ht:label?: x1-17001r1.4.2 -->
                                                                                            
                                                                                            
  </figure>
<p>  This led to a new approach I invented, and supervised a Masters student to prototype and evaluate,
the Form-based Mapper [<a 
href="#Xli2002data">53</a>]. This uses form visualisations of XML data models – meant to be
analogous to the business forms traditionally used to exchange data between businesses e.g. fill
out an order form, send to supplier, supplier copies data from form to another format,
supplier processes order etc. Figure 1.7  shows an example of the Form-based Mapper in
use.
</p> 
<p>  Key features of the Form-based Mapper include:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>Problem domain: data exchange between complex business systems
      </p> 
</li>
      <li class="itemize">
      <p>Target user group(s): non-technical domain experts
      </p> 
</li>
      <li class="itemize">
      <p>Key meta-model elements: business form structures – represented as XML models
      </p> 
</li>
      <li class="itemize">
      <p>DSVL(s) used: hierarchical “form” visualisation meant to resemble real-world paper and
      electronic forms
      </p> 
</li>
      <li class="itemize">
      <p>Transformation approach used: XSLT scripts
      </p> 
</li>
      <li class="itemize">
      <p>Target generated artefacts: XSLT scripts</p> 
</li></ul>
<p>  The domain end user e.g. someone who is knowledgeable about the data to be exchanged between
businesses, imports an XML schema and has it visualised as a form like layout, as in Figure 1.7  (1).
The user may rearrange the format to look more like a real-world paper or electronic form. They then
specify via drag and drop “correspondences” between form elements, as shown in Figure 1.7  (1) and
(2). Some of these, like the correspondences in Figure 1.7  (1) can be simple one to one mappings with
little or no data format translation; some can be 1:many or many:many complex data
transformations. A formulae builder is provided (examples shown bottom text field in Figure
1.7  (1) and (2)) allows specification of formula-based data transformations, meant to be
like spreadsheet-like formulae. The Form-based Mapper then generates XSLT scripts to
implement XML to XML data transformations based on the specified mappings, part of
one shown in Figure 1.7  (3). One issue we found when evaluating the format translation
formulae is these are difficult to end users to use, being themselves based on XSLT-based
formulae.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.4.3   </span> <a 
 id="x1-180001.4.3"></a>Mobile App Generation Tools</h4>
<p>Developing mobile apps has become very popular but is still predominantly limited to those with high
development expertise. Despite the availability of a range of low-code/no-code MDE-based app
generation and configuration tools, these have major limitations around flexibility, expressive power,
and quality of generated mobile app [<a 
href="#Xbarnett2019supporting">10</a>]. Despite these limitations of MDE-based app generation
approaches, eHealth apps are a promising area for modelling and generating fully functional apps.
                                                                                            
                                                                                            
This is because eHealth apps in specific domains share many commonalities. We wanted to support
public health clinicians in modelling and generating eHealth apps for chronic disease management e.g.
diabetes, obesity, etc. These all use a similarly-structured “care plan” concept and mobile apps
provide patients with self-management steps following a set of exercise, diet, pharmacology and
monitoring interventions. We developed a clinician-oriented chronic disease management app
modeller and generator for this domain [<a 
href="#Xkhambati2008model">48</a>]. An example of this in use is shown in Figure 1.8
.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/vcpml.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-18001r8"></a>
<a 
 id="x1-18002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.8: </span></span><span  
class="content"><span 
class="cmss-10">Example of the Visual Care Plan Modelling Language eHealth app generator in use (from [</span><a 
href="#Xkhambati2008model"><span 
class="cmss-10">48</span></a><span 
class="cmss-10">])</span>      </span></figcaption><!--tex4ht:label?: x1-18001r1.4.3 -->
                                                                                            
                                                                                            
  </figure>
<p>  Key features of this Visual Care Plan Modeling Language (VCPML)-based eHealth app generator
include:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>Problem domain: eHealth apps for chronic disease management
      </p> 
</li>
      <li class="itemize">
      <p>Target user group(s): clinicians model app care plans and tailor to individual patient
      needs, patients use generated eHealth app
      </p> 
</li>
      <li class="itemize">
      <p>Key meta-model elements: care plans and app interface components
      </p> 
</li>
      <li class="itemize">
      <p>Visual  Care  Plan  Modelling  Language  (VCPML)  and  a  visual  interface  specification
      language
      </p> 
</li>
      <li class="itemize">
      <p>Transformation approach used: C implemented code generators
      </p> 
</li>
      <li class="itemize">
      <p>Target generated artefacts: OpenLaszlo code which itself is then translated into Flash or
      Microsoft Mobile code to run on (old) phone platforms</p> 
</li></ul>
<p>  Figure 1.8  (1) shows a VCPML diagram to support patients with obseity management. The idea
for VCPML came from medical texts where these care plans were textually described, and we
developed a meta-model and visual model to describe them. These can be hierarchical, with Figure
1.8  (2) showing a more detailed care plan relating to physical therapy after clicking on the icon in
Figure 1.8 (1). A further visual language (not shown) is used to describe the details of how to present
care plan elements in a mobile phone GUI. An OpenLaszlo implementation of the mobile app is
generated, itself then transformed into one or more specific mobile app implementations. The one
shown in Figure 1.8  (3) is a Flash-based implementation running on a handset with a
Flash player embedded. This is a 1000% code generation approach - unlike our RAPPT
tool described previously, the generated code can not be changed. While in theory the
VCPML approach to chronic disease management app generation was good, a number of
limitations were encountered by users. These included confusing user interface specification
language; lack of accounting for diverse users of the mobile apps in the generated apps – a one
size fits all approach; and inability to change or augment generated app appearance and
functionality.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.4.4   </span> <a 
 id="x1-190001.4.4"></a>DSVL Tool Generators – “DSVL Meta-tools”</h4>
<p>As discussed previously, we need to implement sophisticated support tools in order to realise DSVL
and MDE based approaches. We have found that such DSVL-based tools themselves are amenable to
using DSVL+MDE approaches, given they have many commonalities, common meta-models and
DSVLs can be developed to describe them, and much of their functionality can be generated, as either
code or configurations. I have used DSVL and MDE techniques to specify and generate many
DSVL-based tools - I call these meta-tools or meta-DSVL tools [<a 
href="#Xgrundy2000constructing">35</a>, <a 
href="#Xgrundy2012generating">37</a>]. One such example is the
                                                                                            
                                                                                            
Vikibuilder, a DSVL and MDE-based tool for specifying Visual Wikis [<a 
href="#Xhirsch2010vikibuilder">44</a>]. An example
of VikiBuilder in use to specify a “Lost” TV series Visual Wiki is shown in Figure 1.9
.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/vikibuilder.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-19001r9"></a>
<a 
 id="x1-19002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.9: </span></span><span  
class="content"><span 
class="cmss-10">Example of the VikiBuilder Visual Wiki designer and generator in use (from [</span><a 
href="#Xhirsch2010vikibuilder"><span 
class="cmss-10">44</span></a><span 
class="cmss-10">])</span>                 </span></figcaption><!--tex4ht:label?: x1-19001r1.4.4 -->
                                                                                            
                                                                                            
  </figure>
      <ul class="itemize1">
      <li class="itemize">
      <p>Problem domain: Generating “visual wikis”
      </p> 
</li>
      <li class="itemize">
      <p>Target user group(s): Visual wiki designers - not necessarily software engineers (unless
      they want to author their own Java plug-ins to extend the platform – see below).
      </p> 
</li>
      <li class="itemize">
      <p>Key meta-model elements: key visual wiki elements e.g. data sources, data filters, data
      transformations, various visual wiki screen elements
      </p> 
</li>
      <li class="itemize">
      <p>DSVL(s) used: a simple box and line visual wiki element composer, itself realised as a
      Visual Wiki (thus VikiBuilder is itself a “meta-Visual Wiki”)
      </p> 
</li>
      <li class="itemize">
      <p>Transformation approach used: Java code creating database content
      </p> 
</li>
      <li class="itemize">
      <p>Target generated artefacts: creates a database containing configuration information for
      the new visual wiki, which is interpreted to create the new Visual Wiki on the Confluence
      platform ; additional hand-implemented Java code plug-ins can be added to enhance
      functionality</p> 
</li></ul>
<p>  Figure 1.9  (1) shows part of the specification of a new Lostpedia Visual Wiki that is intended to
provide an interactive, visual way of exploring the Lostpedia site. Various details about data sources,
filters, transformations, aggregations, and visualisations are specified using form-based
information associated with each visual wiki DSVL element, as shown Figure 1.9  (2). Note the
VikiBuilder tool is itself a Visual Wiki built on top of the Confluence Enterprise Wiki
platform with a set of Java plug-ins. The new visual Wiki can be tested and specifications,
both DSVL elements and their properties updated interactively, shown in Figure 1.9  (3).
Finally the complete Lostpedia Visual Wiki can be deployed for use, shown in Figure 1.9
(4).
</p> 
<p>  The generator takes the specified visual wiki information and populates a database with essentially
a set of detailed configuration model information, rather than generating code to implement the
Visual Wiki. A single Visual Wiki code platform thus interprets different detailed specification models
to produce quite different Visual Wikis. The VikiBuilder is thus a good example of model
to model transformation using MDE, rather than model to code. In addition, software
engineers can specify Java-based plugins to include in the new visual wiki that use a set
of APIs to extend the platform capabilities, to include functionality not built into our
original Visual Wiki platform. The VikiBuilder also thus illustrates semi-automated use of
MDE to produce solutions – the DSVL allows modelling of a wide range of concepts, but
ones not catered for it supports specifying Java plugins to use that are hand-coded by
developers.
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.4.5   </span> <a 
 id="x1-200001.4.5"></a>Reverse-engineering DSVL Models from Code</h4>
<p>All of the examples I have shown so far of DSVLs and MDE use “forward engineering” – high level
                                                                                            
                                                                                            
model to lower level model to code/script/configuration model. Sometimes it is useful to use “reverse
engineering” where a high level DSVL-visualised model is extracted from lower level models, code,
documentation, performance logs, etc. An example of such a tool is DCTracVis, a tool that we
developed to address the problem of visualising a large number of reverse-engineered traceability links
between code and documentation [<a 
href="#Xchen2018dctracvis">15</a>]. Figure 1.10  shows an example of DCTracVis in
use.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/dctracvis.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-20001r10"></a>
<a 
 id="x1-20002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.10: </span></span><span  
class="content"><span 
class="cmss-10">Example of the DCTracVis traceability link reverse engineering tool in use (from [</span><a 
href="#Xchen2018dctracvis"><span 
class="cmss-10">15</span></a><span 
class="cmss-10">])</span>            </span></figcaption><!--tex4ht:label?: x1-20001r1.4.5 -->
                                                                                            
                                                                                            
  </figure>
<p>  Key features of DCTracVis include:
  </p> 

      <ul class="itemize1">
      <li class="itemize">
      <p>Problem  domain:  want  to  visualise  and  explore  interactively  a  large  number  of
      reverse-engineered traceability links between source code and documentation
      </p> 
</li>
      <li class="itemize">
      <p>Target user group(s): software engineers
      </p> 
</li>
      <li class="itemize">
      <p>Key meta-model elements: code abstract syntax tree, document paragraphs and words,
      and links between code tree elements and document words/phrases.
      </p> 
</li>
      <li class="itemize">
      <p>DSVL(s) used: a heat map and tree visualisation
      </p> 
</li>
      <li class="itemize">
      <p>Transformation approach used: Java-based reverse engineering tool to extract models
      from Java source code and PDF documents
      </p> 
</li>
      <li class="itemize">
      <p>Target generated artefacts: higher level model of tracelinks between code elements and
      documentation elements</p> 
</li></ul>
  <figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/softarch2.png" alt="PIC"  
width="483" height="483"  /> <a 
 id="x1-20003r11"></a>
<a 
 id="x1-20004"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.11: </span></span><span  
class="content"><span 
class="cmss-10">Example of the SoftArch/MTE performance engineering tool showing augmented DSVL with reverse</span>
<span 
class="cmss-10">engineered data (from [</span><a 
href="#Xgrundy2005softarch"><span 
class="cmss-10">26</span></a><span 
class="cmss-10">])</span>                                                                      </span></figcaption><!--tex4ht:label?: x1-20003r1.4.5 -->
                                                                                            
                                                                                            
  </figure>
<p>  Figure 1.10  shows a complex Java program that has been analysed and its Packages (collections of
Java classes) shown as group of heat map visualised items (left hand side “Packages”
heat map). A set of PDF documents and section headings within the PDFs are show in
the right hand side heat map (“Documents”). When the software engineer clicks on a
node – a Java class – in the left hand side Packages heat map, elements corresponding
to sections in the documentation about this class are highlighted in the right hand side
Documents heat map. A tree visualisation of links is also shown at the bottom, here showing a
traceability link from the selected javax.naming class to three sections in the jndspi.pdf
documentation file explaining uses of this Java class. The developer can then go into the PDF at
each indicated section to see potentially useful information about using this javax.naming
class.
</p> 
<p>  Tools that use DSVLs and MDE for forward-engineering can also use reverse-engineering and
annotation of their DSVL diagrams to show e.g. run-time reverse engineered information. An example
of this is used in our SoftArch/MTE, Marama/MTE and Cloud/MTE performance engineering tools
[<a 
href="#Xgrundy2005softarch">26</a>, <a 
href="#Xdraheim2006realistic">19</a>]. These extract low-level run-time performance data after running performance tests, abstract
this data into high level performance summaries, and visualise these summaries by highlighting DSVL
diagram icons. Figure 1.11  shows an example of this in Softarch/MTE [<a 
href="#Xgrundy2005softarch">26</a>]. A software
architecture DSVL model (1) is highlighted with shading and line thickness to show – at a
high architectural level – places in the architecture design causing potential performance
bottle-necks. The data is abstracted from run-time captured low-level performance data, shown
in (2), and can also be visualised in an alternative way using a bar chart, as shown in
(3).
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.5   </span> <a 
 id="x1-210001.5"></a>Overview of the papers in this Thesis</h3>
<p>Figure 1.12  shows a summary of many of the tools and approaches described in the papers that make
up this thesis, with an indicator to which part/chapter they appear in. Each tool/approach is briefly
introduced and summarised in the following subsections. At the top of Figure 1.12  are several
DSVL-based meta-tools and various extensions to support more human-centric and collaborative
modelling with these DSVLs. A range of software engineer-supporting tools are shown below the
timeline in Figure 1.12  in blue, supporting a range of requirements, architecture, design, coding,
testing and process management tasks. A set of end-user oriented tools are shown in red at the
bottom of Figure 1.12 .
</p> 
<p>  The collection of papers I include in Part 1 describe ways in which DSVL-based MDE tools can be
described and implemented, including themselves using DSVL and MDE-based approaches. In Parts
2-4, a collection of papers describe why DSVLs can be a good choice for various aspects of software
engineering, including requirements engineering, software architecture, design, testing and to support
software process modelling and enactment. In Part 5, the selected papers describe a body of
my work creating various “human-centric” and collaborative support facilities that can
aid the use of DSVL-based MDE approaches in various ways. In Part 6 I include several
papers presenting reasons and examples of why DSVL-based MDE tools can also be used
to support non-technical software end users to model and build their own software, in
a wide variety of constrained domains. Finally, in Part 7 a recent paper outlines some
future directions in supporting more human-centric model-driven software engineering using
DSVLs.
  </p> 
<figure class="figure"> 

                                                                                            
                                                                                            
                                                                                            
                                                                                            
<p><img 
src="figures/timeline.png" alt="PIC"  
width="483" height="256"  /> <a 
 id="x1-21001r12"></a>
<a 
 id="x1-21002"></a>
</p> 
<figcaption class="caption" ><span class="id"><span 
class="cmssbx-10">Figure</span><span 
class="cmssbx-10"> 1.12: </span></span><span  
class="content"><span 
class="cmss-10">Approximate timeline of this thesis collected contributions</span>                                   </span></figcaption><!--tex4ht:label?: x1-21001r1.5 -->
                                                                                            
                                                                                            
  </figure>
  <h4 class="subsectionHead"><span class="titlemark">1.5.1   </span> <a 
 id="x1-220001.5.1"></a>Part 1 – Modelling tools and their development</h4>
<p>In order to realise the approach of DSVLs and MDE to produce software systems, we need tools to
model with DSVLs and generate other models/code/configurations etc. from these models with
these DSVLs. The papers in this part of the thesis describe selected examples of a range
of solutions we have produced to realise such tools. These examples include post-PhD
work on a number MViews framework extensions, the JViews framework, the JComposer
DSVL- and MDE-based JViews modeller and code generator, the Pounamu DSVL-based
meta-tool, the Marama Eclipse IDE-based meta-tool, and the VikiBuilder Visual Wiki
modeller and generator. Using these platforms my collaborators and I have realised dozens
of innovative DSVL and MDE-based tools for both software engineers and end users in
diverse application domains. These results have been published in well over 200 of my
papers.
</p> 
<p>  MViews (implemented in an OO Prolog) and JViews (implemented in Java) are Object-oriented
(OO) frameworks for building DSVL-based tools, and provide some code and model generation
support using MDE. However building DSVL-based tools with these frameworks requires
textual-coding and specialising complex framework classes, time- consuming and only suitable for
expert programmers to do. <strong><em><span 
class="cmbxti-10x-x-120">“Constructing component-based software engineering</span>
<span 
class="cmbxti-10x-x-120">environments: issues and experiences”</span></em></strong> [<a 
href="#Xgrundy2000constructing">35</a>] describes JComposer, itself a JViews-based DSVL
and MDE meta-tool for modelling and partially generating JViews-based DSVL and MDE tools. We
describe the need for DSVL-based meta-tools like JComposer, its capabilities and evaluation of its
support, including architectural support for distributed, collaborative work specifying and partially
generating DSVL-based tools. JComposer supports modelling of partial DSVL tools. It then uses
MDE to generate partial DSVL tool implementation code using the JViews Java class
framework. These partial tool implementations are then completed by tool developers
modifying and extending by hand the generated Java class code to complete the tool.
JComposer results in much quicker/easier DSVL-based tool development in JViews than using
JViews alone. JComposer, like JViews, was intended for software engineers to use, as it
requires quite a lot of coding knowledge for its Java framework class specialisation and
implementation.
</p> 
<p>  Inconsistency between DSVL views frequently occurs when a designer modifies e.g. a high level
process model or requirements model using a DSVL, but it is unclear how this change can/should be
translated to a design-level DSVL model or code-level text. This becomes a more complex problem as
more diagram (view) types are added, collaborative work between multiple designers is supported,
and various kinds of models are integrated. <strong><em><span 
class="cmbxti-10x-x-120">“Inconsistency Management for Multi-view</span>
<span 
class="cmbxti-10x-x-120">Software Development Environments”</span></em></strong> [<a 
href="#Xgrundy1998inconsistency">32</a>] describes a range of extensions made to the
Prolog-based MViews platform (originally developed in my PhD) and its successor Java-based JViews
framework to support inconsistency management in DSVL-based tools. We show a range of
inconsistencies that can result and novel ways to manage them when trying to keep various
general-purpose and domain-specific graphical representations of software engineering
models consistent. MViews and JViews were both intended for software engineers to use, as
they require a lot of coding knowledge for their OO framework class specialisation and
implementation.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">Pounamu: a meta-tool for exploratory domain-specific visual language tool</span>
<span 
class="cmbxti-10x-x-120">development</span></em></strong> [<a 
href="#Xzhu2007pounamu">73</a>] describes Pounamu, the successor DSVL meta-tool to JComposer/JViews.
Pounamu is a stand-alone, Java-implemented meta-tool with a greater range of DSVL-based
meta-tools, and it generates DSVL tool specification files which are interpreted by Pouanmu itself to
realise the target DSVL-based tool. Pounamu supports development of Java code-based plug-ins to
                                                                                            
                                                                                            
extend the generated tool functionality in more seamless ways than JViews. A number of extensions
to Pounamu support collaborative work and web- and mobile-based editing, described
in later thesis chapters. We have used Pounamu to build a wide range of DSVL-based
tools for software engineers and end users. Pounamu was intended for software engineers
to use, as it requires some coding knowledge for its Java plug-ins, though we have also
had some end users successfully use it to develop their own DSVL-based tools in limited
ways.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">Generating Domain-Specific Visual Language Tools from Abstract Visual</span>
<span 
class="cmbxti-10x-x-120">Specifications</span></em></strong> [<a 
href="#Xgrundy2012generating">37</a>] describes Marama, the successor to Pounamu. Marama is a DSVL meta-tool
realised by a set of Eclipse IDE-based plug-ins, rather than a stand-alone tool like Pounamu.
Marama provides much more sophisticated DSVL-based tool specification than Pounamu or
JComposer, and many more extensions via its own Eclipse plug-ins and also via many
third-party Eclipse IDE plug-ins. This includes Eclipse-based code development IDEs, making
Marama-based tools much more closely integrated with other development tools than in our
previous meta-tool approaches. Marama even has a DSVL-based MDE code generator
specification and generation tool – a DSVL-based meta-MDE tool [<a 
href="#Xhuh2009integrated">45</a>]. It also has a range
of novel DSVL-based design critic and constraint modelling and generation tools, these
making complex DSVL-based tool functionality much easier to build than Pounamu and
JViews/JComposer [<a 
href="#Xali2007generic">2</a>]. We have used Marama to build a wide range of DSVL-based tools for
software engineers and end users. Marama was intended for software engineers to use,
but we have had non-technical end users successfully use it to build basic DSVL-based
tools.
</p> 
<p>  Finally in this part I describe <strong><em><span 
class="cmbxti-10x-x-120">VikiBuilder: end-user specification and generation of</span>
<span 
class="cmbxti-10x-x-120">Visual Wikis</span></em></strong> [<a 
href="#Xhirsch2010vikibuilder">44</a>]. As previously summarised, VikiBuilder is a web-based, DSVL-based Visual Wiki
specification and generation tool. It is itself a Visual Wiki and generates Visual Wiki configuration
data via MDE from its DSVL-based models. Unlike the previous meta-tools, VikiBuilder was always
intended for end user, non-technical user specification and generation of Visual Wikis. It can also be
used by software engineers who can develop Java-based plug-ins to extend the Visual Wikis generated
by VikiBuilder.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.5.2   </span> <a 
 id="x1-230001.5.2"></a>Part 2 – Requirements and Design support with DSVLs and MDE</h4>
<p>We have used our meta-tools from the previous section, and others, to develop a wide range of tools
to support software engineers during requirements engineering and software architecting tasks for
complex software systems. An early example is a set of extensions to existing DSVLs – those of
JComposer – described in <strong><em><span 
class="cmbxti-10x-x-120">Aspect-oriented Requirements Engineering for Component-based</span>
<span 
class="cmbxti-10x-x-120">Software Systems</span></em></strong> [<a 
href="#Xgrundy1999aspect">25</a>]. In this work, I invented a set of novel requirements-level “aspect”
annotations on high level components describing cross-cutting problem space concerns. These
augmented JComposer requirements-level specifications and allow a software engineer to
describe and reason about cross-cutting concerns in DSVL-based tools, as well as other
DSVL-described software requirements. We later added this concept to general purpose
UML diagrams, used them to augment design level models, and used them to describe
implemented software component capabilities to support run-time dynamic integration of
component-based systems. JComposer uses MDE to take its aspect-augmented requirements
DSVL models and generate design-level detailed aspect information (via model to model
transformation).
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">MaramaAIC: Tool Support for Consistency Management and Validation of</span>
<span 
class="cmbxti-10x-x-120">Requirements</span></em></strong> [<a 
href="#Xkamalrudin2017maramaaic">46</a>] describes MaramaAIC, a tool supporting requirments engineering using Essential
                                                                                            
                                                                                            
Use Case (EUC)-based models and Essential User Interface (EUI) models. MaramaAIC provides
a novel DSVL-based representation of these EUC based requirements models and uses
MDE to generate EUCs from essential interaction models extracted from natural language
text. It also generates example user interface mockups using MDE from its EUI based
DSVL models. MaramaAIC was, as the name suggests, implemented using our Marama
meta-tools.
</p> 
<p>  Software security engineering is challenging. <strong><em><span 
class="cmbxti-10x-x-120">Adaptable, Model-driven Security Engineering</span>
<span 
class="cmbxti-10x-x-120">for SaaS Cloud-based Applications</span></em></strong> [<a 
href="#Xalmorsy2014adaptable">5</a>] describes several DSVLs to support modelling different
aspects of software security, including requirements-level and design-level characteristics.
MDE-based tool support enables requirements level software security properties to be translated
to solution space architecture and design level choices to realise security requirements.
Further MDE support assists developers in encoding these DSVL-specified security solution
decisions into software component code and configurations. This includes supporting run-time
security property management. Finally, low-level run-time security monitoring data can be
reverse-engineered and abstracted into design level DSVL-visualised information for system security
managers.
</p> 
<p>  SoftArch is a tool I developed to model a range of complex software architecture abstractions.
<strong><span 
class="cmbx-12">SoftArch: tool support for integrated software architecture development</span></strong> [<a 
href="#Xgrundy2003softarch">29</a>]
describes the DSVLs provided by Softarch to support a range of software architecture
modelling at various levels of abstraction. MDE techniques are used to generate partial
OO design models to exchange with other modelling tools. Reverse engineering is used to
provide dynamic visualisation of running systems based on these models. Softarch DSVLs
can be augmented by running system data to debug and understand how the systems
work.
</p> 
<p>  Design patterns are reusable solution approaches to tackling common design and programming
problems. They are often described with UML-based design models. <strong><em><span 
class="cmbxti-10x-x-120">A Visual Language for</span>
<span 
class="cmbxti-10x-x-120">Design Pattern Modelling and Instantiation</span></em></strong> [<a 
href="#Xmaplesden2001visual">56</a>] describes a novel DSVL, the Design Pattern
Modelling Language (DPML), used for describing design patterns, and MDE techniques for realising
these in programming code. A supporting tool, DPMLTool, was originally implemented with the
JViews/JComposer meta-tool. A more advanced version, MaramaDPML, was subsequently
reimplemented with the Marama meta-tool.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.5.3   </span> <a 
 id="x1-240001.5.3"></a>Part 3 – Development and Testing with DSVLs and MDE</h4>
<p>We have invented many innovative DSVL- and MDE-based tools to support design, implementation
and testing of software systems. <strong><em><span 
class="cmbxti-10x-x-120">Supporting Multi-View Development for Mobile</span>
<span 
class="cmbxti-10x-x-120">Applications</span></em></strong> [<a 
href="#Xbarnett2019supporting">10</a>] describes RAPPT, a DSVL- and DSL-based mobile app code generation tool.
Described previously, RAPPT supports combined visual DSVLs for high level mobile app modelling
combined with more detailed textual DSL models to describe lower level app designs. These are then
used to generate a fully functioning Android app including code, manifest, configuration
and build files. The generated code is intended to be further hand-edited to polish and
complete the app. RAPPT was intended for professional app developers to increase their
productivity.
</p> 
<p>  I have described many uses of model transformation, used in our DSVL meta-tools and in several
example tools. Most of these are usually implemented as Java code, XSLT transformation
scripts, or using other textual DSL code generator scripting languages. <strong><em><span 
class="cmbxti-10x-x-120">Specifying Model</span>
<span 
class="cmbxti-10x-x-120">Transformations by Direct Manipulation using Concrete Visual Notations and</span>
<span 
class="cmbxti-10x-x-120">Interactive Recommendations</span></em></strong> [<a 
href="#Xavazpour2015specifying">7</a>] describes CoNVErT, a DSVL-based model-to-model and
                                                                                            
                                                                                            
model-to-visualisation mapping and generation tool. This paper describes the visual model-to-model
specification aspects of CoNVERT – its domain-specific DSVLs used to visualise XML models, its
model to model visual mapping specification DSVL, and its mapping generator that uses
MDE to transform its models to a detailed XML model transformation implementation.
CoNVERT was intended for non-technical end users, but can be used by software engineers
too.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">SoftArch/MTE: Generating Distributed System Test-beds from High-level Software</span>
<span 
class="cmbxti-10x-x-120">Architecture Descriptions</span></em></strong> [<a 
href="#Xgrundy2005softarch">26</a>] describes extensions to SoftArch including augmented software
architecture DSVL diagrams and MDE to generate performance test-beds for these architectures to
support large scale software performance engineering. As discussed previously, testing whether a
planned complex software system will meet its performance targets is very challenging. In this paper
we describe how we augmented the original Softarch DSVL-based software architecture models
to add detailed implementation platform and client, server and database properties and
templates to synthesize realistic client loading models and server and database models. We
describe how we generate these detailed models using XSLT-based model transformation
approaches. We also describe the reverse engineering and abstraction of detailed run-time
performance data into summaries and display of these to the user by augmenting the
architectral DSVL models. SoftArch/MTE was implemented with our JViews/JComposer
meta-tool.
</p> 
<p>  Previously I described and illustrated MaramaMTE, a successor to Softarch/MTE for distributed
system test bed generation and performance engineering. <strong><em><span 
class="cmbxti-10x-x-120">Realistic Load Testing of Web</span>
<span 
class="cmbxti-10x-x-120">Applications</span></em></strong> [<a 
href="#Xdraheim2006realistic">19</a>] describes using novel DSVL-based models in MaramaMTE – augmented
architecture diagrams and augmented stochastic form charts – to model and generate via MDE
web-based system performance test beds. Unlike the JViews-based Softarch/MTE, MaramaMTE is
fully integrated into the Eclipse IDE as a toolset and makes use of third party Eclipse
plug-ins to provide a much more integrated performance engineering toolset for software
engineers.
</p> 
<p>  Finally in this part I describe TeeVML, a performance emulation <em><span 
class="cmti-12">environment</span></em> generator.
Softarch/MTE and MaramaMTE described above generate fully functional models of
complex distributed systems that are compiled and run with associated environment software
(database servers, web servers etc) to performance test them. In contrast, TeeVML and its
supporting tool generate “emulation environments” to test the behaviour and performance of
real, very large scale software systems in mock emulation environments – essentially the
opposite of MaramaMTE and Softarch/MTE. <strong><em><span 
class="cmbxti-10x-x-120">A Domain-Specific Visual Modeling</span>
<span 
class="cmbxti-10x-x-120">Language for Testing Environment Emulation</span></em></strong> [<a 
href="#Xliu2016domain">54</a>] describes this approach where a
new DSVL-based high-level model of “system endpoints” – basically models of complex
software system interfaces – are used to model and generate the complex environment a
real-world software system would have to operate in. This software system is then run in this
generated emulation environment, instead of having to hand-construct a (very) complex
testing environment for it. TeeVML is implemented with the commercial MetaEDIT+
meta-tool.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.5.4   </span> <a 
 id="x1-250001.5.4"></a>Part 4 – Process and Project Management with DSVLs and MDE</h4>
<p>Software process models can be very complex. In the 1990s there was a lot of interest
in (semi-)automated tools to model and enact (run) process models to guide software
development. <strong><em><span 
class="cmbxti-10x-x-120">Serendipity: integrated environment support for process modelling,</span>
<span 
class="cmbxti-10x-x-120">enactment and work coordination</span></em></strong> [<a 
href="#Xgrundy1998serendipity">39</a>] describes Serendipity, such a process-centred
                                                                                            
                                                                                            
environment. A set of DSVLs are used by developers to model complex software processes.
Serendipity then uses MDE to generate detailed software process models from these DSVLs
that are then run – or enacted – to implement the specified software process and guide
developers in following it. Serendipity provides a range of high-level and detailed software
process descriptions, including “agents” that monitor software development tool activities
to semi-automate complex software processes. Serendipity users are software engineers,
particularly project leaders. Serendipity was implemented with the MViews meta-tool
framework.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">A decentralized architecture for software process modeling and enactment</span></em></strong> [<a 
href="#Xgrundy1998decentralized">36</a>]
describes the successor to Serendipity, Serendipity-II. This supports a more powerful visual editing
tool, more advanced collaborative work and third party tool integration, and some improved DSVLs.
Serendipity-II generates process models using MDE like Serendipity, but also generates Java code
using MDE to implement a variety of tool integration support features. End users of Serendipity-II
were originally intended to be software engineers, but it can also be used by non-technical project
managers in other domains. Serendipity-II was implemented with the JComposer meta-tool and
JViews framework.
</p> 
<p>  Specifying complex software security requirements and behaviours is challenging, especially for end
users whose security requirements may evolve over time. In <strong><em><span 
class="cmbxti-10x-x-120">Collaboration-Based Cloud</span>
<span 
class="cmbxti-10x-x-120">Computing Security Management Framework</span></em></strong> [<a 
href="#Xalmorsy2011collaboration">4</a>] we present a combined DSVL- and
DSL-based framework to support the process of specifying and enforcing end-to-end, complex,
cloud-based Software as a Service (SaaS)-based application security requirements. From these models
we generate detailed security properties for the target system using MDE. These models are then used
at run-time to configure a running cloud-based SaaS application’s run-time security enforcement
approaches. End users are SaaS application owners, often non-technical end users. Software engineers
can also use the toolset to model security requirements and have them enforced at run-time. An early
version of our web-based Horus meta-tool [<a 
href="#Xalmorsy2014horuscml">6</a>] and a set of web forms are used to specify the security
models.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">DCTracVis: a system retrieving and visualizing traceability links between source code</span>
<span 
class="cmbxti-10x-x-120">and documentation</span></em></strong> [<a 
href="#Xchen2018dctracvis">15</a>] describes the DCTracVis reverse engineering tool introduced previously.
Unlike many of the systems presented in this thesis, DCTracVis abstracts higher-level models from
low-level code – documentation links, reverse engineered using text processing algorithms.
It then uses Heat Map- and Tree-based DSVL representations of these models to allow
software engineers to browse between high-level links between documentation and code
elements.
</p> 
<p>  BiDaML is a tool for modelling complex data analytics applications, described in <strong><em><span 
class="cmbxti-10x-x-120">An End-to-End</span>
<span 
class="cmbxti-10x-x-120">Model-based Approach to Support Big Data Analytics Development</span></em></strong> [<a 
href="#Xkhalajzadeh2020end">47</a>]. BiDaML uses
several DSVLs ranging from high-level brainstorming diagrams to low-level technique diagrams
to specify complex data analytics applications from varying perspectives. MDE-based
generators produce detailed reports to guide data analytics teams, and partial Java and Python
implementations of data analytics applications. End users are multi-disciplinary data analytics
team members – domain experts, business analysts, software engineers, project managers
and cloud platform experts. BiDaML is implemented with the commercial MetaEDIT+
meta-tool.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.5.5   </span> <a 
 id="x1-260001.5.5"></a>Part 5 – Human-centric DSVL Modelling and Collaboration</h4>
<p>In this part of the thesis I describe several research works that look to support more “human-centric”
modelling with DSVL-based MDE tools. By this I mean approaches to make the tools easier to use,
                                                                                            
                                                                                            
support more “natural” modelling, and support multiple developers or end users working
collaboratively together on models.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">Experiences developing architectures for realising thin-client diagram editing tools</span></em></strong>
[<a 
href="#Xgrundy2007experiences">31</a>] describes a variety of Pounamu extensions to enable users of Pounamu tools to edit DSVL
diagrams using a web brower, mobile phone and even a 3D browser plug-in. The idea is that Pounamu
is a Java-based application that needs to be installed on each users machine and regularly updated.
Similarly, due to Pounamu’s use of Java code plug-ins for much DSVL-based tool implementation,
this makes sharing new DSVL tools and developing them collaboratively very challenging.
Pounamu/Thin – the web/mobile-supporting extensions – instead host a single Pounamu
instance on a server and provide web browser/mobile phone editing interfaces. Some of
the web browser editors are quite sophisticated, using SVG and ECMA script to provide
highly interactive diagramming very similar to the desktop Pouanu. Note also that this
work was done in the mid-2000s, long before today’s more powerful browser-based client
capabilities were developed. Pounamu/Thin even allows Pounamu meta-tool specifications to be
edited and thus new Pounamu-based DSVL tools to be designed using the browser-based
interface.
</p> 
<p>  In <strong><em><span 
class="cmbxti-10x-x-120">Engineering plug-in software components to support collaborative work</span></em></strong> [<a 
href="#Xgrundy2002engineering">28</a>] we
describe a set of JViews-based plug-ins that provide a range of collaborative work facilities to
JViews-based DSVL editing tools. A wide range of plug-ins are provided to support collaborative
editing, awareness support, shared repositories, process-centred environment control and annotation
of change histories, and so on. These plug-ins use the aspect-based extensions to JViews and
JComposer to support very dynamic, run-time plug-in support.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">A generic approach to supporting diagram differencing and merging for collaborative</span>
<span 
class="cmbxti-10x-x-120">design</span></em></strong> [<a 
href="#Xmehra2005generic">57</a>] presents a set of Pounamu and early Marama plug-ins that support collaborative work
via DSVL diagram comparison and merging support. When working with other designers on a shared
DSVL designs, such support is essential to enable changes made simultaneously or asynrhconously to
be compared, and selected changes to be “committed” to a shared, unified model. The techniques
described in this paper are generic and work for any Pounamu or Marama DSVL-based
tool.
</p> 
<p>  DSVLs don’t have to be just two dimensional, box-and-line diagrams. <strong><span 
class="cmbx-12">A 3D Business</span>
<span 
class="cmbx-12">Metaphor for Program Visualization</span></strong> [<a 
href="#Xpanas20033d">61</a>] proposes a highly novel DSVL for visualising
project management information using a 3D “city” metaphor of buildings, streets and
various annotations. Like DCTracVis, we reverse engineer detailed project management
information, abstract it, then use the city metaphor to visualise the project management
data. Forward engineering from these project management visualisations using MDE was
proposed to allow restructuring of projects based on modifications made to the city-based
DSVLs.
</p> 
<p>  Finally, bringing much of the prior works in this part together, we describe “sketching-based”
interfaces to DSVL tools in <strong><em><span 
class="cmbxti-10x-x-120">Supporting generic sketching-based input of diagrams in a</span>
<span 
class="cmbxti-10x-x-120">domain-specific visual language meta-tool</span></em></strong> [<a 
href="#Xgrundy2007supporting">30</a>]. This describes a set of Marama plug-ins
enabling sketching-based input of sketched designs, much as one would using a whiteboard or piece of
paper. The sketched diagrams are automatically formalised into underlying Marama DSVL models.
These sketch-supporting plug-ins also work with Marama versions of our collaborative work
supporting plug-ins to support distributed, collaborative, sketched-based DSVL tools! The
techniques described in this paper are generic and work for any Marama DSVL-based
tool.
</p> 
<p>
  </p> 

                                                                                            
                                                                                            
  <h4 class="subsectionHead"><span class="titlemark">1.5.6   </span> <a 
 id="x1-270001.5.6"></a>Part 6 – End user Applications of DSVLs and MDE</h4>
<p>While many of the tools we have produced are for software engineers to help in their work, we have
also produced many DSVL- and MDE-basd tools for end users, usually focused on very specific
domains of work. In this part I overview several papers that support a diverse range of end users and
diverse range of end user application domains.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">Domain-specific visual languages for specifying and generating data mapping</span>
<span 
class="cmbxti-10x-x-120">systems</span></em></strong> [<a 
href="#Xgrundy2004domain">40</a>] describes several tools aimed at supporting complex data integration, most aimed at
supporting end users in different domains e.g. business analysts, construction engineers, and eHealth
system integrators. Tools described include the Orion Message Mapper and Form-based Mapper
described previously. Some of the data integration tools described were designed and built with
MViews and JViews frameworks.
</p> 
<p>  In <strong><em><span 
class="cmbxti-10x-x-120">A domain-specific visual language for report writing</span></em></strong> [<a 
href="#Xdantra2009domain">18</a>], we describe a tool developed
with an industrial partner, PRISM, who build sophisticated software solutions for the commercial
print industry. One of their software systems is a DSL-based report generation tool, to be used by
print industry experts. This paper describes a DSVL-based report writing designer and
generator. A DSVL is used to specify complex print industry report layout and content. MDE
approaches are used to generate the textual DSL language, which is then complied and run by
PRISM’s existing software. The DSVL- and MDE-based approach makes authoring, modifying
and understanding these complex professional print industry reports easier, faster and
more maintainable. PRISM commercialised the prototype toolset. Our DSVL-based report
designer was implemented with Microsoft Visual Studio’s DSVL-based designers and code
generators.
</p> 
<p>  HorusHPC, described previously, is aimed at scientists wanting to parallelise software for high
performance computing domains. <strong><span 
class="cmbx-12">Supporting Scientists in Re-engineering Sequential</span>
<span 
class="cmbx-12">Programs to Parallel Using Model-driven Engineering</span></strong> [<a 
href="#Xalmorsy2015supporting">3</a>] describes its DSVLs and web-based
toolset. It uses MDE to generate lower-level models and GPU C code skeletons. Scientists then
complete these code skeletons by hand. Partial HorusHPC models can also be reverse engineered from
existing C code.
</p> 
<p>  <strong><em><span 
class="cmbxti-10x-x-120">A visual language and environment for enterprise system modelling and</span>
<span 
class="cmbxti-10x-x-120">automation</span></em></strong> [<a 
href="#Xli2014visual">52</a>] describes Enterprise Modelling Langugae (EML) and its support tool, described
earlier in this chapter. EML and EMLTool were designed for enterprise service modelling
and generation of service orchestration scripts. EML is a DSVL using novel tree- and
overlay-based metaphors. EMLTool supports creagting EML models, and uses these EML models
to generate BPML4WS service orchestrations using Eclipse model transformer and code
generation plug-ins. A third party BPEL analyser checks for problems in the specifications and
uses a DSVL to highlight these to the user. EMLTool was realised using our Marama
meta-toolset.
</p> 
<p>  Described previously, Statistical Design Language (SDL) and its supporting tool, SDLTool, are
aimed at professional and amateur statisticians, and provide multiple DSVLs for high-level to
low-level statistical survey designs. These are described in <strong><em><span 
class="cmbxti-10x-x-120">A suite of visual languages for</span>
<span 
class="cmbxti-10x-x-120">model-driven development of statistical surveys and services, Journal of Visual</span>
<span 
class="cmbxti-10x-x-120">Languages and Computing</span></em></strong> [<a 
href="#Xkim2015suite">49</a>]. MDE techniques are used to generate R scripts and web
service implementations of specified survey technique descriptions for reuse. SDLTool was
implemented using the Pounamu meta-tools, along with a number of specially designed Pounamu
plug-ins.
</p> 
<p>  Finally in this part of the thesis I describe the use of CoNVERT for information integration and
complex visualisation, in the context of household travel data aggregation, harmonisation, integration
and visualisation. The paper <strong><em><span 
class="cmbxti-10x-x-120">Engineering Complex Data Integration and Harmonization</span>
<span 
class="cmbxti-10x-x-120">Systems</span></em></strong> [<a 
href="#Xavazpour2019engineering">8</a>] presents an industry collaboration with the AURIN project and Data61 to source,
analyse, aggregate, harmonise, transform, integrate, and visualise complex household travel survey
                                                                                            
                                                                                            
data from several Australian states. End users of the DSVL-based tool are domain experts in human
geography-based survey data, government planning, and use of diverse government planning
data.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.5.7   </span> <a 
 id="x1-280001.5.7"></a>Part 7 – Future directions</h4>
<p>The single paper in this part of the thesis, <strong><em><span 
class="cmbxti-10x-x-120">Towards Human-Centric Model-Driven Software</span>
<span 
class="cmbxti-10x-x-120">Engineering</span></em></strong> [<a 
href="#Xgrundy2020towards">33</a>], outlines a new research programme for more human-centric, model-driven
software engineering. This reseaerch includes integrating diverse human characteristics into
requirements-level and design-level DSVLs and using these human characteristics during model-driven
engineering. The MDE generators either generate different apps and web site pages tailored to
different end users, or generate configuration data that can be used by the apps/web sites at run-time
to tailor them to diverse end user human characteristics. This work builds heavily on the
contributions of many of the papers presented earlier in the thesis. It attempts to address some of the
limitations of these works, specifically the lack of modelling diverse end user characteristics, such
as age, gender, language, culture, personality, emotions, etc in DSVLs, and the lack of
using this information during MDE to produce software better suited to diverse end user
needs.
</p> 
<p>
  </p> 

  <h3 class="sectionHead"><span class="titlemark">1.6   </span> <a 
 id="x1-290001.6"></a>Evidence of Impact</h3>
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.6.1   </span> <a 
 id="x1-300001.6.1"></a>Citations</h4>
<p>The research community has utilised the results from the papers in this thesis to inform
many other research projects by many leading groups internationally. These are illustrated
by both number of citations to many of the works, as well as citation of the works by
many leading research teams. For example, several papers have over 200 citations (Google
Scholar), or the paper in this thesis and its earlier conference version having together well
over 200 citations. Examples include papers on Inconsistency management in MViews
and Views [<a 
href="#Xgrundy1998inconsistency">32</a>], collaborative cloud security modelling end enactment [<a 
href="#Xalmorsy2011collaboration">4</a>], design pattern
modelling and instantiation [<a 
href="#Xmaplesden2001visual">56</a>], collaborative DSVL diagram diffing and merging [<a 
href="#Xmehra2005generic">57</a>],
and aspect-oriented requirements engineering [<a 
href="#Xgrundy1999aspect">25</a>]. Many other papers, or the papers in
this thesis and earlier conference version, have well over 100 citations. Examples include
JViews/JComposer, Pounamu and Marama meta-tools papers and their earlier conference versions
[<a 
href="#Xgrundy2000constructing">35</a>, <a 
href="#Xzhu2007pounamu">73</a>, <a 
href="#Xgrundy2012generating">37</a>], MaramaAIC essential use case DSVL-based tool [<a 
href="#Xkamalrudin2017maramaaic">46</a>], MaramaMTE web
application testbed modeller and generator [<a 
href="#Xdraheim2006realistic">19</a>], Serendipity process-centred environment
[<a 
href="#Xgrundy1998serendipity">39</a>], Serendipity-II workflow modelling and enactment toolset [<a 
href="#Xgrundy1998decentralized">36</a>], City metaphor project
management information visualisation tool [<a 
href="#Xpanas20033d">61</a>], and JViews-based collaborative editing plug-ins
[<a 
href="#Xgrundy2002engineering">28</a>].
                                                                                            
                                                                                            
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.6.2   </span> <a 
 id="x1-310001.6.2"></a>Industrial collaborations and Translation to practice</h4>
<p>Many of the research works in this thesis have been carried out in collaboration with a wide range of
industrial partners. In addition, a number of the meta-tools have been used on follow-on projects with
these or other collaborators.
</p> 
<p>  We have developed and used our data mapping tools, including the Orion Message Mapper,
Form-based Mapper [<a 
href="#Xgrundy2004domain">40</a>] and CoNVERT [<a 
href="#Xavazpour2015specifying">7</a>], with several companies interested in complex data
integration problems. These include Orion Health, Peace Software, XSOL, First Data Utilities,
NICTA, VicRoads and AURIN. The Orion Message mapper was a prototype for the very successful
Raphsody message mapping and integration toolset produced and commercialised by Orion
Heath.
</p> 
<p>  We have used our process-modelling and workflow-modelling tools, including Serendipity and
Serendipity-II [<a 
href="#Xgrundy1998serendipity">39</a>, <a 
href="#Xgrundy1998decentralized">36</a>] derivatives of these, or our meta-tools Pounamu and Marama [<a 
href="#Xzhu2007pounamu">73</a>, <a 
href="#Xgrundy2012generating">37</a>], to
implement similar prototype systems, for several domains. This includes modelling complex business
process models with XSOL and Peace Software. The city visualisation DSVL and prototype tool were
developed in collaboration with Peace Software’s R&#x0026;D team [<a 
href="#Xpanas20033d">61</a>]. A summer student used
Serendipity-II ideas to prototype a workflow tool with Peace Software to model and co-ordinate
complex billing system processes. This was subsequently commercialised by Peace development
teams.
</p> 
<p>  We used our performance engineering tools, including Softarch/MTE and MaramaMTE [<a 
href="#Xgrundy2005softarch">26</a>, <a 
href="#Xdraheim2006realistic">19</a>], on
several industrial projects, several of them as confidential consulting projects on large scale enterprise
system performance analysis and improvement. Some projects we are able to talk about include
performance engineering of virtual database-based systems with XSOL, large scale clinical data
repository engineering with Orion Health, and large scale database systems performance
engineering with First Data Utilities. We collaborated with CSIRO on Softarch/MTE
development [<a 
href="#Xgrundy2005softarch">26</a>]. This included using information from CSIRO collaborations with a range
of large Australian corporates with complex enterprise system performance engineering
needs. A patent for the principles underpinning Softarch/MTE was successfully applied
for.
</p> 
<p>  We collaborated with Swiss consulting company Sofismo AG to attempt a commercialisation of a
derivative of the Marama meta-toolset [<a 
href="#Xgrundy2012generating">37</a>]. This was to underpin Sofismo’s complex system
modelling and analysis work, carried out with a wide range of predominantly European
corporates.
</p> 
<p>  TeeVML development [<a 
href="#Xliu2016domain">54</a>] was informed by our collaboration with CA Labs on generating complex
enterprise system emulation environments. The idea was to augment CA Lab’s commercial toolsets
with support for very large scale testing environment modelling with TeeVML DSVL-based
models, and then generate test bed emulation environments from these models using MDE
techniques.
</p> 
<p>  We have collaborated with several scientific and medical discovery teams using, among others,
HorusHPC [<a 
href="#Xalmorsy2015supporting">3</a>] and BiDaML [<a 
href="#Xkhalajzadeh2020end">47</a>]. These included the astrophysics team at Swinburne University of
Technology on modelling complex radio telescope data process software for pulsar discovery, and
the medical imaging team at the Alfred Hospital on MRI image processing for disease
identification.
</p> 
<p>  We collaborated with Thales on developing improved requirements engineering tools for complex air
traffic control and related systems. This included modelling and semi-formalising textual requirements
using DSVL models using MaramaAIC [<a 
href="#Xkamalrudin2017maramaaic">46</a>].
</p> 
<p>  We have worked with several companies during the development and evaluation of BiDaML [<a 
href="#Xkhalajzadeh2020end">47</a>].
This included real estate cost estimation algorithms with ANZ bank, predicting congestion for
Melbourne CBD using VicRoads data, and recently with eHealth application developers.
                                                                                            
                                                                                            
</p> 
<p>  Our report writing DSVL-based tool was commercialised by PRISM [<a 
href="#Xdantra2009domain">18</a>]. This involved turning the
initial prototype into an “industrialised” version, supporting larger scale reports, multiple user
editing, and versioning.
</p> 
<p>  For our Visual Wiki and VikiBuilder [<a 
href="#Xhirsch2010vikibuilder">44</a>] work we successfully applied for a US patent for its
underlying principles. We then secured very significant venture capital funding to commercialise this
as the Mohio information visualisation platform.
</p> 
<p>
  </p> 

  <h4 class="subsectionHead"><span class="titlemark">1.6.3   </span> <a 
 id="x1-320001.6.3"></a>Next Generation Education and Training</h4>
<p>The impact I am most proud of from this body of work is the number and range of students,
post-doctoral fellows and research assistants who I have worked with and educated in this domain.
We used Pounamu and Marama tools for several years in our undergraduate final year
software engineering course, many undergraduate Honors student projects, and in several
graduate courses on domain-specific visual languages at the University of Auckland. While not
having precise number of student teams or individual projects, well over 200 students
used the tools to learn about DSVL and MDE principles and built their own DSVL- and
MDE-tools.
</p> 
<p>  Just contributing to the papers contained in this thesis alone, there are a total of 14 PhD students,
10 Masters by research students and 1 Honors student, and 10 post-doctoral fellows and 3 research
assistants. Most of these students, research assistants and post-doctoral fellows have gone into
industry positions with this knowledge and skills. Of the rest, 6 have academic positions and 4 have
post-doctoral fellow positions as I write this. Including the many other derivative works using
JViews/JComposer, Pounamu, Marama, and a few using third party frameworks and toolkits, there
are a great many more students, research assistants and post-doctoral fellows who have
benefited from learning in the environment and with the techniques and toolsets that we have
created.
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 2</span><br /><a 
 id="x1-330002"></a>DSVL Modelling Tool Development</h2>
  <h3 class="sectionHead"><span class="titlemark">2.1   </span> <a 
 id="x1-340002.1"></a>Constructing component-based software engineering environments: issues and
experiences</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Mugridge, W.B. and Hosking, J.G. Constructing component-based software
engineering environments: issues and experiences, <em><span 
class="cmti-12">Information and Software Technology</span></em>, Vol 42, No.
2, Elsevier, January 2000, Pages 103-114.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/S0950-5849(99)00084-1" >10.1016/S0950-5849(99)00084-1</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>Developing software engineering tools is a difficult task, and the environments in which
these tools are deployed continually evolve as software developers’ processes, tools and tool sets
evolve. To more effectively develop such evolvable environments, we have been using component-based
approaches to build and integrate a range of software development tools, including CASE
and workflow tools, file servers and versioning systems, and a variety of reusable software
agents. We describe the rationale for a component-based approach to developing such tools,
the architecture and support tools we have used some resultant tools and tool facilities
we have developed, and summarise the possible future research directions in this area.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for the approach, co-led design of the approach,
implemented most of the software, led evaluation of the platform, co-authored substantial parts of the
paper, investigator for funding for the work from the Foundation for Research Science and Technology
(FRST) <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ist2000.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">2.2   </span> <a 
 id="x1-350002.2"></a>Inconsistency Management for Multi-view Software Development Environments</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Mugridge, W.B. Inconsistency Management for Multi-view Software
Development Environments, <em><span 
class="cmti-12">IEEE Transactions on Software Engineering</span></em>, Vol. 24, No. 11, 1998, pp.
960 - 981.
</p> 
<p>  DOI: <a 
href="http://dx.doi.org/10.1109/32.730545" >10.1109/32.730545</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>Developers need tool support to help manage the wide range of inconsistencies that occur
during software development. Such tools need to provide developers with ways to define, detect,
record, present, interact with, monitor and resolve complex inconsistencies between different views of
software artifacts, different developers and different phases of software development. This paper
describes our experience with building complex multiple-view software development tools that
support diverse inconsistency management facilities. We describe software architectures we have
developed, user interface techniques used in our multiple-view development tools, and discuss
the effectiveness of our approaches compared to other architectural and HCI techniques.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Led development of the key ideas, co-designed the approach, implemented most of
the software, led evaluation of the platform, wrote most of the paper, one of the investigators on grant
for funding for the work from the Foundation for Research Science and Technology (FRST)
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/tse98.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">2.3   </span> <a 
 id="x1-360002.3"></a>Pounamu: a meta-tool for exploratory domain-specific visual language tool development</h3>
<p>Zhu, N., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Liu, N., Cao, S. and Mehra, A. Pounamu: a meta-tool for
exploratory domain-specific visual language tool development, <em><span 
class="cmti-12">Journal of Systems and Software</span></em>,
Elsevier, vol. 80, no. 8, August 2007, Pages 1390-1407.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jss.2006.10.028" >10.1016/j.jss.2006.10.02</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>Domain-specific visual language tools have become important in many domains of software
engineering and end user development.However building such tools is very challenging with a need for
multiple views of information and multi-user support, the ability for users to change tool diagram
and meta-model specifications while in use, and a need for an open architecture for tool
integration.We describe Pounamu, a meta-tool for realising such visual design environments. We
describe the motivation for Pounamu, its architecture and implementation and illustrate
examples of domain-specific visual language tools that we have developed with Pounamu.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed initial ideas for the approach, co-led design of the approach,
co-supervised research assistant, 1 PhD and two Masters students working on software, led evaluation
of the platform, wrote substantial parts of the paper, co-lead investigator for funding for the work
from Foundation for Research Science and Technology <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jss2007.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">2.4   </span> <a 
 id="x1-370002.4"></a>Generating Domain-Specific Visual Language Tools from Abstract Visual Specifications</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Li, N., Li, L., Ali, N.M., Huh, J. Generating Domain-Specific Visual
Language Tools from Abstract Visual Specifications, <em><span 
class="cmti-12">IEEE Transactions on Software Engineering</span></em>,
vol. 39, no. 4, April 2013, pp. 487 - 515
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/TSE.2012.33" >10.1109/TSE.2012.33</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>Domain-specific visual languages support high-level modeling for a wide range of
application domains. However, building tools to support such languages is very challenging. We
describe a set of key conceptual requirements for such tools and our approach to addressing these
requirements, a set of visual language-based metatools. These support definition of metamodels,
visual notations, views, modeling behaviors, design critics, and model transformations and provide a
platform to realize target visual modeling tools. Extensions support collaborative work, human-centric
tool interaction, and multiplatform deployment. We illustrate application of the metatoolset on
tools developed with our approach. We describe tool developer and cognitive evaluations
of our platform and our exemplar tools, and summarize key future research directions.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed initial ideas for the approach, co-led design of the approach, wrote
initial software for the approach, co-supervised research assistant and 3 PhD students working on
project, oversaw evaluation of the platform, wrote substantial amounts of the paper, co-lead
investigator for funding for the work from Foundation for Research Science and Technology
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/tse2013.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">2.5   </span> <a 
 id="x1-380002.5"></a>VikiBuilder: end-user specification and generation of Visual Wikis</h3>
<p>Hirsch, C., Hosking, J.G. and <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> VikiBuilder: end-user specification and generation of
Visual Wikis, In <em><span 
class="cmti-12">Proceedings of the 25th IEEE/ACM International Conference on Automated Software</span>
<span 
class="cmti-12">Engineering</span></em>, Antwerp, Belgium, 20-24 Sept 2010, ACM, pp 13–22.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1145/1858996.1859002" >10.1145/1858996.1859002</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>With the need to make sense out of large and constantly growing information spaces, tools
to support information management are becoming increasingly valuable. In prior work we proposed
the ”Visual Wiki” concept to describe and implement web-based information management
applications. By focusing on the integration of two promising approaches, visualizations and
collaboration tools, our Visual Wiki work explored synergies and demonstrated the value of the
concept. Building on this, we introduce ”VikiBuilder”, a Visual Wiki meta-tool, which provides
end-user supported modeling and automatic generation of Visual Wiki instances. We describe the
design and implementation of the VikiBuilder including its architecture, a domain specific visual
language for modeling Visual Wikis, and automatic generation of those. To demonstrate the utility of
the tool, we have used it to construct a variety of different Visual Wikis. We describe the
construction of Visual Wikis and discuss the strengths and weaknesses of our meta-tool approach.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial idea for the approach, co-designed the approach, co-supervised
PhD student working on project, co-authored significant amount of the paper, co-lead investigator for
funding for the work from Foundation for Research Science and Technology and BuildIT.
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ase2010_1.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 3</span><br /><a 
 id="x1-390003"></a>DSVLs and MDE for Software Requirements and Architectures</h2>
  <h3 class="sectionHead"><span class="titlemark">3.1   </span> <a 
 id="x1-400003.1"></a>Aspect-oriented Requirements Engineering for <br 
class="newline" />Component-based Software Systems</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> Aspect-oriented Requirements Engineering for Component-based Software Systems,
<em><span 
class="cmti-12">1999 IEEE Symposium on Requirements Engineering</span></em>, Limmerick, Ireland, 7-11 June, 1999, IEEE, pp
84 - 91.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/ISRE.1999.777988" >10.1109/ISRE.1999.777988</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong>Developing requirements for software components, and ensuring these requirements
are met by component designs, is very challenging, as very often application domain and
stakeholders are not fully known during component development. The author introduces a
new methodology, aspect-oriented component engineering, that addresses some difficult
issues of component requirements engineering by analysing and characterising components
based on different aspects of the overall application a component addresses. He gives an
overview of the aspect-oriented component requirements engineering process, focus on
component requirements analysis specification and reasoning, and briefly discuss tool support.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Sole author ; developed all ideas, software, wrote whole paper. <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/re1999.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">3.2   </span> <a 
 id="x1-410003.2"></a>MaramaAIC: Tool Support for Consistency Management and Validation of Requirements</h3>
<p>Kamalrudin, M., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., MaramaAIC: Tool Support for Consistency
Management and Validation of Requirements, <em><span 
class="cmti-12">Automated Software Engineering</span></em>, Springer, 2017, vol
24, no 1, pp. 1-45.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1007/s10515-016-0192-z" >10.1007/s10515-016-0192-z</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Requirements captured by requirements engineers (REs) are commonly inconsistent
with their client’s intended requirements and are often error prone. There is limited tool
support providing end-to-end support between the REs and their client for the validation
and improvement of these requirements. We have developed an automated tool called
MaramaAIC (Automated Inconsistency Checker) to address these problems. MaramaAIC
provides automated requirements traceability and visual support to identify and highlight
inconsistency, incorrectness and incompleteness in captured requirements. MaramaAIC
provides an end-to-end rapid prototyping approach together with a patterns library that
helps to capture requirements and check the consistency of requirements that have been
expressed in textual natural language requirements and then extracted to semi-formal abstract
interactions, essential use cases (EUCs) and user interface prototype models. It helps engineers to
validate the correctness and completeness of the EUCs modelled requirements by comparing
them to “best-practice” templates and generates an abstract prototype in the form of
essential user interface prototype models and concrete User Interface views in the form of
HTML. We describe its design and implementation together with results of evaluating
our tool’s efficacy and performance, and user perception of the tool’s usability and its
strengths and weaknesses via a substantial usability study. We also present a qualitative
study on the effectiveness of the tool’s end-to-end rapid prototyping approach in improving
dialogue between the RE and the client as well as improving the quality of the requirements.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Contribution: Co-developed main idea for the approach, co-developed tool design,
co-supervised PhD student, wrote substantial parts of paper, co-led investigator for funding for this
project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/asej2017.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">3.3   </span> <a 
 id="x1-420003.3"></a>Adaptable, Model-driven Security Engineering for SaaS Cloud-based Applications</h3>
<p>Almorsy, M., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Ibrahim, A., Adaptable, Model-driven Security Engineering for SaaS
Cloud-based Applications, <em><span 
class="cmti-12">Automated Software Engineering</span></em>, vol. 21, no. 2, April 2014, Springer, pp.
187–224.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1007/s10515-013-0133-z" >10.1007/s10515-013-0133-z</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Software-as-a-service (SaaS) multi-tenancy in cloud-based applications helps service
providers to save cost, improve resource utilization, and reduce service customization and
maintenance time. This is achieved by sharing of resources and service instances among multiple
“tenants” of the cloud-hosted application. However, supporting multi-tenancy adds more
complexity to SaaS applications required capabilities. Security is one of these key requirements
that must be addressed when engineering multi-tenant SaaS applications. The sharing of
resources among tenants—i.e. multi-tenancy—increases tenants’ concerns about the security
of their cloud-hosted assets. Compounding this, existing traditional security engineering
approaches do not fit well with the multi-tenancy application model where tenants and their
security requirements often emerge after the applications and services were first developed.
The resultant applications do not usually support diverse security capabilities based on
different tenants’ needs, some of which may change at run-time i.e. after cloud application
deployment. We introduce a novel model-driven security engineering approach for multi-tenant,
cloud-hosted SaaS applications. Our approach is based on externalizing security from the
underlying SaaS application, allowing both application/service and security to evolve at
runtime. Multiple security sets can be enforced on the same application instance based on
different tenants’ security requirements. We use abstract models to capture service provider
and multiple tenants’ security requirements and then generate security integration and
configurations at runtime. We use dependency injection and dynamic weaving via Aspect-Oriented
Programming (AOP) to integrate security within critical application/service entities at
runtime. We explain our approach, architecture and implementation details, discuss a usage
example, and present an evaluation of our approach on a set of open source web applications.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Contribution: Developed initial ideas for the research, co-supervised the two PhD
students, co-authored significant parts of paper <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/asej2014.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">3.4   </span> <a 
 id="x1-430003.4"></a>SoftArch: tool support for integrated software architecture development</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, and Hosking, J.G. SoftArch: tool support for integrated software architecture
development, <em><span 
class="cmti-12">International Journal of Software Engineering and Knowledge Engineering</span></em>, vol 13, no 2,
April 2003, World Scientific, pp. 125-151.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1142/S0218194003001238" >10.1142/S0218194003001238</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> A good software architecture design is crucial in successfully realising an object-oriented
analysis (OOA) specification with an object-oriented design (OOD) model that meets the
specification’s functional and non-functional requirements. Most CASE tools and software
architecture design notations do not adequately support software architecture modelling and analysis,
integration with OOA and OOD methods and tools, and high-level, dynamic architectural
visualisations of running systems. We describe SoftArch, an environment that provides flexible
software architecture modelling using a concept of successive refinement and an extensible
architecture meta-model. SoftArch provides extensible analysis tools enabling developers
to analyse their architecture model properties. Run-time visualisation of systems uses
dynamic annotation and animation of high-level architectural modelling views. SoftArch is
integrated with a component-based CASE tool and run-time monitoring tool, and has
facilities for 3rd party tool integration through a common exchange format. This paper
discusses the motivation for SoftArch, its modelling, analysis and dynamic visualisation
capabilities, and its integration with various analysis, design and implementation tools.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, wrote the software
the approach based on, wrote majority of the paper, co-lead investigator for funding for this project
from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ijseke2003.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">3.5   </span> <a 
 id="x1-440003.5"></a>A Visual Language for Design Pattern Modelling and Instantiation</h3>
<p>Maplesden, D., Hosking, J.G. and <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, A Visual Language for Design Pattern Modelling
and Instantiation, <em><span 
class="cmti-12">Chapter 2 in Design Patterns Formalization Techniques</span></em>, Toufik Taibi (Ed), Idea
Group Inc., Hershey, USA, March 2007, pp. 20-43. DOI: <a 
href="https://doi.org/10.4018/978-1-59904-219-0.ch002" >10.4018/978-1-59904-219-0.ch002</a>
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> In this chapter we describe the Design pattern modeling language, a notation supporting
the specification of Design pattern solutions and their instantiation into UML design models. DPML
uses a simple set of visual abstractions and readily lends itself to tool support. DPML Design pattern
solution specifications are used to construct visual, formal specifications of Design patterns. DPML
instantiation diagrams are used to link a Design pattern solution specification to instances of a UML
model, indicating the roles played by different UML elements in the generic Design pattern
solution. A prototype tool is described, together with an evaluation of the language and tool.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-designed approach, wrote some of the software the approach based on,
co-supervised Masters student, co-authored significant parts of the paper, co-lead investigator for
funding for this project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/patterns2007.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 4</span><br /><a 
 id="x1-450004"></a>Software Development and Testing using DSVLs and MDE</h2>
  <h3 class="sectionHead"><span class="titlemark">4.1   </span> <a 
 id="x1-460004.1"></a>Supporting Multi-View Development for Mobile Applications</h3>
<p>Barnett, S., Avazpour, I., Vasa, R., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> Supporting Multi-View Development for Mobile
Applications, <em><span 
class="cmti-12">Journal of Computer Languages</span></em>, Volume 51, April 2019, Elsevier, Pages
88-96
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.cola.2019.02.001" >10.1016/j.cola.2019.02.001</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Interest in mobile application development has significantly increased. The
need for rapid, iterative development coupled with the diversity of platforms, technologies
and frameworks impacts on the productivity of developers. In this paper we propose a
new approach and tool support, Rapid APPlication Tool (RAPPT), that enables rapid
development of mobile applications. It employs Domain Specific Visual Languages and Modeling
techniques to help developers define the characteristics of their applications using high level
visual notations. Our approach also provides multiple views of the application to help
developers have a better understanding of the different aspects of their application. Our user
evaluation of RAPPT demonstrates positive feedback ranging from expert to novice developers.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed main ideas for the research, co-supervised PhD student, wrote
substantial part of the paper <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jcl2019.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">4.2   </span> <a 
 id="x1-470004.2"></a>Specifying Model Transformations by Direct Manipulation using Concrete Visual Notations
and Interactive Recommendations</h3>
<p>Avazpour, I., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Grunske, L. Specifying Model Transformations by Direct Manipulation
using Concrete Visual Notations and Interactive Recommendations, <em><span 
class="cmti-12">Journal of Visual Languages and</span>
<span 
class="cmti-12">Computing</span></em>, Volume 28, June 2015, Elsevier,pp 195–211.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jvlc.2015.02.005" >10.1016/j.jvlc.2015.02.005</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Model transformations are a crucial part of Model-Driven Engineering (MDE) technologies
but are usually hard to specify and maintain for many engineers. Most current approaches use
meta-model-driven transformation specification via textual scripting languages. These
are often hard to specify, understand and maintain. We present a novel approach that
instead allows domain experts to discover and specify transformation correspondences using
concrete visualizations of example source and target models. From these example model
correspondences, complex model transformation implementations are automatically generated. We
also introduce a recommender system that helps domain experts and novice users find
possible correspondences between large source and target model visualization elements.
Correspondences are then specified by directly interacting with suggested recommendations
or drag and drop of visual notational elements of source and target visualizations. We
have implemented this approach in our prototype tool-set, CONVErT, and applied it to a
variety of model transformation examples. Our evaluation of this approach includes a
detailed user study of our tool and a quantitative analysis of the recommender system.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, co-supervised PhD
student, wrote substantial parts of paper, investigator for funding for this project from ARC
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jvlc2015_2.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">4.3   </span> <a 
 id="x1-480004.3"></a>SoftArch/MTE: Generating Distributed System Test-beds from High-level Software
Architecture Descriptions</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Cai, Y. and Liu, A. SoftArch/MTE: Generating Distributed System Test-beds from
High-level Software Architecture Descriptions, <em><span 
class="cmti-12">Automated Software Engineering</span></em>, Kluwer Academic
Publishers, vol. 12, no. 1, January 2005, pp. 5-39
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1023/B:AUSE.0000049207.62380.74" >10.1023/B:AUSE.0000049207.62380.74</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Most distributed system specifications have performance benchmark requirements, for
example the number of particular kinds of transactions per second required to be supported by the
system. However, determining the likely eventual performance of complex distributed system
architectures during their development is very challenging. We describe SoftArch/MTE, a software
tool that allows software architects to sketch an outline of their proposed system architecture at a
high level of abstraction. These descriptions include client requests, servers, server objects and
object services, database servers and tables, and particular choices of middleware and
database technologies. A fully-working implementation of this system is then automatically
generated from this high-level architectural description. This implementation is deployed on
multiple client and server machines and performance tests are then automatically run for this
generated code. Performance test results are recorded, sent back to the SoftArch/MTE
environment and are then displayed to the architect using graphs or by annotating the original
high-level architectural diagrams. Architects may change performance parameters and
architecture characteristics, comparing multiple test run results to determine the most suitable
abstractions to refine to detailed designs for actual system implementation. Further tests may
be run on refined architecture descriptions at any stage during system development. We
demonstrate the utility of our approach and prototype tool, and the accuracy of our generated
performance test-beds, for validating architectural choices during early system development.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, wrote some of the
software the approach based on, co-supervised Masters student, wrote majority of the paper, co-lead
investigator for funding for this project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/asej2004.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">4.4   </span> <a 
 id="x1-490004.4"></a>Realistic Load Testing of Web Applications</h3>
<p>Draheim, D., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Lutteroth, C. and Weber, G. Realistic Load Testing of
Web Applications, In <em><span 
class="cmti-12">Proceedings of the 10th European Conference on Software Maintenance and</span>
<span 
class="cmti-12">Re-engineering</span></em>, Berlin, 22-24 March 2006, pp 57-70.
</p> 
<p>  DOI: <a 
href="https://doi.ieeecomputersociety.org/10.1109/CSMR.2006.43" >10.1109/CSMR.2006.43</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> We present a new approach for performing load testing of web applications by
simulating realistic user behaviour with stochastic form-oriented analysis models. Realism in
the simulation of user behaviour is necessary in order to achieve valid testing results. In
contrast to many other user models, web site navigation and time delay are modelled
stochastically. The models can be constructed from sample data and can take into account
effects of session history on user behaviour and the existence of different categories of
users. The approach is implemented in an existing architecture modelling and performance
evaluation tool and is integrated with existing methods for forward and reverse engineering.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed some of the key initial ideas for this research, co-designed approach,
wrote the software the approach based on, wrote substantial parts of the paper, co-lead investigator
for funding for this project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/csmr2006.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">4.5   </span> <a 
 id="x1-500004.5"></a>A Domain-Specific Visual Modeling Language for Testing Environment Emulation</h3>
<p>Liu, J., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Avazpour, I., Abdelrazek, M. A Domain-Specific Visual Modeling
Language for Testing Environment Emulation, <em><span 
class="cmti-12">2016 IEEE Symposium on Visual Languages</span>
<span 
class="cmti-12">and Human-Centric Computing</span></em>, Cambridge, UK, Sept 4-8 2016, IEEE Press, pp. 143 -
151.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/VLHCC.2016.7739677" >10.1109/VLHCC.2016.7739677</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Software integration testing plays an increasingly important role as the software industry
has experienced a major change from isolated applications to highly distributed computing
environments. Conducting integration testing is a challenging task because it is often very difficult to
replicate a real enterprise environment. Emulating testing environment is one of the key solutions to
this problem. However, existing specification-based emulation techniques require manual coding of
their message processing engines, therefore incurring high development cost. In this paper, we
present a suite of domain-specific visual modeling languages to describe emulated testing
enviroements at a high abstraction level. Our solution allows domain experts to model a testing
environment from abstract interface layers. These layer models are then transformed to runtime
environment for application testing. Our user study shows that our visual languages are
easy to use, yet with sufficient expressive power to model complex testing applications.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial idea for the research, co-developed tool design, co-supervised
PhD student, wrote substantial parts of paper, investigator on funding of the project from the
Australian Research Council <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/vlhcc2016_1.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 5</span><br /><a 
 id="x1-510005"></a>Software Process Management with DSVLs and MDE</h2>
  <h3 class="sectionHead"><span class="titlemark">5.1   </span> <a 
 id="x1-520005.1"></a>Serendipity: integrated environment support for process modelling, enactment and work
coordination</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Hosking, J.G. Serendipity: integrated environment support for process modelling,
enactment and work coordination, <em><span 
class="cmti-12">Automated Software Engineering</span></em>, Vol. 5, No. 1, January 1998,
Kluwer Academic Publishers, pp. 27-60.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1023/A:1008606308460" >10.1023/A:1008606308460</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Large cooperative work systems require work coordination, context awareness and process
modelling and enactment mechanisms to be effective. Support for process modelling and work
coordination in such systems also needs to support informal aspects of work which are difficult to
codify. Computer-Supported Cooperative Work (CSCW) facilities, such as inter-person
communication and collaborative editing, also need to be well-integrated into both process-modelling
tools and tools used to perform work. Serendipity is an environment which provides high-level, visual
process modelling and event-handling languages, and diverse CSCW capabilities, and which can be
integrated with a range of tools to coordinate cooperative work. This paper describes
Serendipity’s visual languages, support environment, architecture, and implementation,
together with experience using the environment and integrating it with other environments.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for the research, did majority of tool design, implemented
and evaluated tool, wrote majority of the paper, investigator for funding for the project from FRST
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ase1998.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">5.2   </span> <a 
 id="x1-530005.2"></a>A decentralized architecture for software process modeling and enactment</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> Hosking, J.G., Mugridge, W.B., Apperley, M.D. A decentralised architecture
for software process modelling and enactment, IEEE Internet Computing, Vol. 2, No. 5,
September/October 1998, IEEE CS Press, pp. 53-62.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/4236.722231" >10.1109/4236.722231</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Many development teams, especially distributed teams, require process support to
adequately coordinate their complex, distributed work practices. Process modeling and enactment
tools have been developed to meet this requirement. The authors discuss the Serendipity-II process
management environment which supports distributed process modeling and enactment for distributed
software development projects. Serendipity-II is based on a decentralized architecture and uses
Internet communication facilities. <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for the research, did majority of tool design, implemented
and evaluated tool, wrote majority of the paper, investigator for funding for the project from FRST
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ic1998.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">5.3   </span> <a 
 id="x1-540005.3"></a>Collaboration-Based Cloud Computing Security Management Framework</h3>
<p>Almorsy, M., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Ibrahim, A. Collaboration-Based Cloud Computing Security
Management Framework, In <em><span 
class="cmti-12">Proceedings of 2011 IEEE International Conference on Cloud</span>
<span 
class="cmti-12">Computing (CLOUD 2011)</span></em>, Washington DC, USA on 4 July – 9 July, 2011, IEEE, pp.
364-371.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/CLOUD.2011.9" >10.1109/CLOUD.2011.9</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Although the cloud computing model is considered to be a very promising internet-based
computing platform, it results in a loss of security control over the cloud-hosted assets. This is due to
the outsourcing of enterprise IT assets hosted on third-party cloud computing platforms. Moreover,
the lack of security constraints in the Service Level Agreements between the cloud providers and
consumers results in a loss of trust as well. Obtaining a security certificate such as ISO 27000 or
NIST-FISMA would help cloud providers improve consumers trust in their cloud platforms’ security.
However, such standards are still far from covering the full complexity of the cloud computing model.
We introduce a new cloud security management framework based on aligning the FISMA standard to
fit with the cloud computing model, enabling cloud providers and consumers to be security
certified. Our framework is based on improving collaboration between cloud providers,
service providers and service consumers in managing the security of the cloud platform and
the hosted services. It is built on top of a number of security standards that assist in
automating the security management process. We have developed a proof of concept of
our framework using. NET and deployed it on a test bed cloud platform. We evaluated
the framework by managing the security of a multi-tenant SaaS application exemplar.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for the research, co-supervised the two PhD students,
wrote substantial parts of paper <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/cloud2011.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">5.4   </span> <a 
 id="x1-550005.4"></a>DCTracVis: a system retrieving and visualizing traceability links between source code and
documentation</h3>
<p>Chen, X., Hosking, J.G., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Amor, R., DCTracVis: a system retrieving and visualizing
traceability links between source code and documentation, <em><span 
class="cmti-12">Automated Software Engineering</span></em>, vol 25,
no 4, 2018, Springer, pp. 703–741
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1007/s10515-018-0243-8" >10.1007/s10515-018-0243-8</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> It is well recognized that traceability links between software artifacts provide crucial
support in comprehension, efficient development, and effective management of a software system.
However, automated traceability systems to date have been faced with two major open research
challenges: how to extract traceability links with both high precision and high recall, and how to
efficiently visualize links for complex systems because of scalability and visual clutter
issues. To overcome the two challenges, we designed and developed a traceability system,
DCTracVis. This system employs an approach that combines three supporting techniques,
regular expressions, key phrases, and clustering, with information retrieval (IR) models
to improve the performance of automated traceability recovery between documents and
source code. This combination approach takes advantage of the strengths of the three
techniques to ameliorate limitations of IR models. Our experimental results show that
our approach improves the performance of IR models, increases the precision of retrieved
links, and recovers more correct links than IR alone. After having retrieved high-quality
traceability links, DCTracVis then utilizes a new approach that combines treemap and
hierarchical tree techniques to reduce visual clutter and to allow the visualization of the global
structure of traces and a detailed overview of each trace, while still being highly scalable
and interactive. Usability evaluation results show that our approach can effectively and
efficiently help software developers comprehend, browse, and maintain large numbers of links.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, co-supervised PhD
student, co-authored significant parts of paper, co-lead investigator for funding for this project from
FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/asej2018-1.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">5.5   </span> <a 
 id="x1-560005.5"></a>An End-to-End Model-based Approach to Support Big Data Analytics Development</h3>
<p>Khalajzadeh, H., Simmons, A., Abdelrazek, M., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., He, Q., An
End-to-End Model-based Approach to Support Big Data Analytics Development, <em><span 
class="cmti-12">Journal of</span>
<span 
class="cmti-12">Computer Languages</span></em>, Volume 58, June 2020, Elsevier
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.cola.2020.100964" >10.1016/j.cola.2020.100964</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> We present BiDaML 2.0, an integrated suite of visual languages and supporting tool to
help multidisciplinary teams with the design of big data analytics solutions. BiDaML tool
support provides a platform for efficiently producing BiDaML diagrams and facilitating
their design, creation, report and code generation. We evaluated BiDaML using two types
of evaluations, a theoretical analysis using the “physics of notations”, and an empirical
study with 1) a group of 12 target end-users and 2) five individual end-users. Participants
mostly agreed that BiDaML was straightforward to understand/learn, and prefer BiDaML
for supporting complex data analytics solution modeling than other modeling languages.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, co-supervised the
two post-doctoral fellows, co-authored significant parts of paper, lead investigator for funding for this
project from ARC <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jcl2020_2.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 6</span><br /><a 
 id="x1-570006"></a>Human-centric DSVL Modelling and Collaboration</h2>
  <h3 class="sectionHead"><span class="titlemark">6.1   </span> <a 
 id="x1-580006.1"></a>Experiences developing architectures for realising thin-client diagram editing tools</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Cao, S., Zhao, D., Zhu, N., Tempero, E. and Stoeckle, H. Experiences
developing architectures for realising thin-client diagram editing tools, <em><span 
class="cmti-12">Software – Practice and</span>
<span 
class="cmti-12">Experience</span></em>, vol. 37, no.12, Wiley, October 2007, pp. 1245-1283
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1002/spe.803" >10.1002/spe.803</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Diagram-centric applications such as software design tools, project planning tools and
business process modelling tools are usually ‘thick-client’ applications running as stand-alone desktop
applications. There are several advantages to providing such design tools as Web-based or even PDA-
and mobile-phone-based applications. These include ease of access and upgrade, provision of
collaborative work support and Web-based integration with other applications. However, building
such thin-client diagram editing tools is very challenging. We have developed several thin-client
diagram editing applications realized as a set of plug-in extensions to a meta-tool for visual design
environment development. In this paper, we discuss key user interaction and software
architecture issues, illustrate examples of interacting with our thin-client diagram editing tools,
describe our design and implementation approaches, and present the results of several
different evaluations of the resultant applications. Our experiences will be useful for those
interested in developing their own thin-client diagram editing architectures and applications.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed key ideas for this research, co-designed approach, co-supervised the
two Masters students and the research assistant, wrote majority of paper, co-lead investigator for
funding for this project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/SPE2007.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">6.2   </span> <a 
 id="x1-590006.2"></a>Engineering plug-in software components to support collaborative work</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Hosking, J.G. Engineering plug-in software components to support
collaborative work, <em><span 
class="cmti-12">Software - Practice and Experience</span></em>, Vol. 32, No. 10, August 2002, Wiley,
983-1013
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1002/spe.472" >10.1002/spe.472</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Many software applications require co-operative work support, including collaborative
editing, group awareness, versioning, messaging and automated notification and co-ordination agents.
Most approaches hard-code such facilities into applications, with fixed functionality and limited
ability to reuse groupware implementations. We describe our recent work in seamlessly adding such
capabilities to component-based applications via a set of collaborative work-supporting plug-in
software components. We describe a variety of applications of this technique, along with descriptions
of the novel architecture, user interface adaptation and implementation techniques for
the collaborative work-supporting components that we have developed. We report on our
experiences to date with this method of supporting collaborative work enhancement of
component-based systems, and discuss the advantages of our approach over conventional techniques.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, wrote and
evaluated the software, wrote majority of paper, co-lead investigator for funding for this project from
FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/spe2002.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">6.3   </span> <a 
 id="x1-600006.3"></a>A generic approach to supporting diagram differencing and merging for collaborative
design</h3>
<p>Mehra, A., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Hosking, J.G. A generic approach to supporting diagram differencing
and merging for collaborative design, In <em><span 
class="cmti-12">Proceedings of the 2005 ACM/IEEE International Conference</span>
<span 
class="cmti-12">on Automated Software Engineering</span></em>, Long Beach, California, Nov 7-11 2005, IEEE Press, pp.
204-213
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1145/1101908.1101940" >10.1145/1101908.1101940</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Differentiation tools enable team members to compare two or more text files, e.g. code or
documentation, after change. Although a number of general-purpose differentiation tools exist for
comparing text documents very few tools exist for comparing diagrams. We describe a new approach
for realising visual differentiation in CASE tools via a set of plug-in components. We have added
diagram version control, visual differentiation and merging support as component-based plug-ins to
the Pounamu meta-CASE tool. The approach is generic across a wide variety of diagram
types and has also been deployed with an Eclipse diagramming plug-in. We describe our
approach’s architecture, key design and implementation issues, illustrate feasibility of our
approach via implementation of it as plug-in components and evaluate its effectiveness.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed key ideas for this research, co-designed approach, co-supervised
Masters student, wrote substantial parts of paper, co-lead investigator for funding for this project
from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/ase2005_1.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">6.4   </span> <a 
 id="x1-610006.4"></a>A 3D Business Metaphor for Program Visualization</h3>
<p>Panas, T., Berrigan, R. and <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> A 3D Business Metaphor for Program Visualization, In
<em><span 
class="cmti-12">Proceedings of the 2003 Conference on Information Visualisation</span></em>, London, 16-18 July 2003, IEEE, pp.
314-319.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/IV.2003.1217996" >10.1109/IV.2003.1217996</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Software development is difficult because software is complex, the software production
process is complex and understanding of software systems is a challenge. We propose a 3D visual
approach to depict software production cost related program information to support software
maintenance. The information helps us to reduce software maintenance costs, to plan the use
of personnel wisely, to appoint experts efficiently and to detect system problems early.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-designed approach, supervised the visiting PhD student, wrote
substantial parts of paper, co-lead investigator for funding for this project from FRST
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/iv2003.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">6.5   </span> <a 
 id="x1-620006.5"></a>Supporting generic sketching-based input of diagrams in a domain-specific visual language
meta-tool</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Hosking, J.G. Supporting generic sketching-based input of diagrams in a
domain-specific visual language meta-tool, In <em><span 
class="cmti-12">Proceedings of the 2007 IEEE/ACM International</span>
<span 
class="cmti-12">Conference on Software Engineering (ICSE’07)</span></em>, Minneapolis, USA, May 2007, IEEE CS Press, pp.
282-291.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/ICSE.2007.81" >10.1109/ICSE.2007.81</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Software engineers often use hand-drawn diagrams as preliminary design artefacts and as
annotations during reviews. We describe the addition of sketching support to a domain-specific visual
language meta-tool enabling a wide range of diagram-based design tools to leverage this
human-centric interaction support. Our approach allows visual design tools generated from high-level
specifications to incorporate a range of sketching-based functionality including both eager and
lazy recognition, moving from sketch to formalized content and back and using sketches
for secondary annotation and collaborative design review. We illustrate the use of our
sketching extension for an example domain-specific visual design tool and describe the
architecture and implementation of the extension as a plug-in for our Eclipse-based meta-tool.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed initial ideas for this research, co-designed approach, wrote and
evaluated the software, wrote majority of paper, co-lead investigator for funding for this project from
FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/icse2007.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 7</span><br /><a 
 id="x1-630007"></a>End-User Applications of DSVLs and MDE</h2>
  <h3 class="sectionHead"><span class="titlemark">7.1   </span> <a 
 id="x1-640007.1"></a>Domain-specific visual languages for specifying and generating data mapping systems</h3>
<p><strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G., Amor, R., Mugridge, W.B., Li, M. Domain-specific visual languages
for specifying and generating data mapping systems, <em><span 
class="cmti-12">Journal of Visual Languages and Computing</span></em>,
vol. 15, no. 3-4, June-August 2004, Elsevier, pp 243-263,
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jvlc.2004.01.003" >10.1016/j.jvlc.2004.01.003</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Many application domains, including enterprise systems integration, health informatics
and construction IT, require complex data to be transformed from one format to another. We have
developed several tools to support specification and generation of such data mappings
using domain-specific visual languages. We describe motivation for this work, challenges in
developing visual mapping metaphors for different target users and problem domains, and
illustrate using examples from several of our developed systems. We compare cognitive
dimension-based evaluations of the different approaches and summarise the lessons we have learned.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed initial ideas for much of this research, co-designed approaches,
developed and evaluated some of the software, co-supervised Masters student, wrote substantial parts
of paper, co-lead investigator for funding for this project from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jvlc2004.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">7.2   </span> <a 
 id="x1-650007.2"></a>A domain-specific visual language for report writing</h3>
<p>Dantra, R., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> and Hosking, J.G. A domain-specific visual language for report writing, In
<em><span 
class="cmti-12">Proceedings of the 2009 IEEE Symposium on Visual Languages and Human-Centric Computing</span></em>,
Cornwallis, Oregon, USA, Sept 20-24 2009, IEEE CS Press, pp 15-22.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/VLHCC.2009.5295308" >10.1109/VLHCC.2009.5295308</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Many domain specific textual languages have been developed for generating complex
reports. These are challenging for novice users to learn, understand and use. We describe our work
developing the prototype of a new visual language tool for a company to augment their textual report
writing language. We describe key motivations for our visual language tool solution, its
architecture, design and development using Microsoft DSL tools, and its evaluation by end-users.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed key ideas for this research, co-designed approach, co-supervised
Masters student, wrote substantial parts of paper, co-lead investigator for funding for this project
from FRST and Technology NZ <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/vlhcc2009_2.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">7.3   </span> <a 
 id="x1-660007.3"></a>Supporting Scientists in Re-engineering Sequential Programs to Parallel Using Model-driven
Engineering</h3>
<p>Almorsy, M. and <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong> Supporting Scientists in Re-engineering Sequential Programs to
Parallel Using Model-driven Engineering, <em><span 
class="cmti-12">1st ICSE Workshop on Software Engineering for High</span>
<span 
class="cmti-12">Performance Computing in Science (SE4HPCS 2015)</span></em>, Florence, Italy, May 19 2015, pp.
1-8.
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1109/SE4HPCS.2015.8" >10.1109/SE4HPCS.2015.8</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Developing complex computational-intensive and data-intensive scientific applications
requires effective utilization of the computational power of the available computing platforms
including grids, clouds, clusters, multi-core and many-core processors, and graphical processing units
(GPUs). However, scientists who need to leverage such platforms are usually not parallel or
distributed programming experts. Thus, they face numerous challenges when implementing and
porting their software-based experimental tools to such platforms. In this paper, we introduce a
sequential-to-parallel engineering approach to help scientists in engineering their scientific
applications. Our approach is based on capturing sequential program details, planned parallelization
aspects, and program deployment details using a set of domain-specific visual languages (DSVLs).
Then, using code generation, we generate the corresponding parallel program using necessary parallel
and distributed programming models (MPI, Open CL, or Open MP). We summarize three case
studies (matrix multiplication, N-Body simulation, and digital signal processing) to evaluate our
approach. <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Came up with initial ideas for the research, co-designed the solution, supervised
the post-doc who implemented solution, lead investigator on grant funding the project from the ARC
<br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/se4hpcs2015.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">7.4   </span> <a 
 id="x1-670007.4"></a>A visual language and environment for enterprise system modelling and automation</h3>
<p>Li, L, <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G. A visual language and environment for enterprise system
modelling and automation,<em><span 
class="cmti-12">Journal of Visual Languages and Computing</span></em>, vol. 25, no. 4, April 2014,
Elsevier, pp. 253-277
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jvlc.2014.03.004" >10.1016/j.jvlc.2014.03.004</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Objective: We want to support enterprise service modelling and generation using a more
end user-friendly metaphor than current approaches, which fail to scale to large organisations with
key issues of “cobweb” and “labyrinth” problems and large numbers of hidden dependencies. Method:
We present and evaluate an integrated visual approach for business process modelling using a novel
tree-based overlay structure that effectively mitigate complexity problems. A tree-overlay based visual
notation (EML) and its integrated support environment (MaramaEML) supplement and integrate
with existing solutions. Complex business architectures are represented as service trees
and business processes are modelled as process overlay sequences on the service trees.
Results: MaramaEML integrates EML and BPMN to provide complementary, high-level
business service modelling and supports automatic BPEL code generation from the graphical
representations to realise web services implementing the specified processes. It facilitates
generated service validation using an integrated LTSA checker and provides a distortion-based
fisheye and zooming function to enhance complex diagram navigation. Evaluations of EML
show its effectiveness. Conclusions: We have successfully developed and evaluated a novel
tree-based metaphor for business process modelling and enterprise service generation. Practice
implications: a more user-friendly modelling approach and support tool for business end users.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed key ideas for this research, co-designed approach, co-supervised
PhD student, wrote substantial parts of paper, co-lead investigator for funding for this project from
FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jvlc2014.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">7.5   </span> <a 
 id="x1-680007.5"></a>A suite of visual languages for model-driven development of statistical surveys and
services</h3>
<p>Kim, C.H., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Hosking, J.G. A suite of visual languages for model-driven development of
statistical surveys and services, <em><span 
class="cmti-12">Journal of Visual Languages and Computing</span></em>, Elsevier, Vol 26, Feb
2015, pp 99–125
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jvlc.2014.11.005" >10.1016/j.jvlc.2014.11.005</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Objective: To provide statistician end users with a visual language environment for
complex statistical survey design and implementation. Methods: We have developed, in conjunction
with professional statisticians, the Statistical Design Language (SDL), an integrated suite of visual
languages aimed at supporting the process of designing statistical surveys, and its support
environment, SDLTool. SDL comprises five diagrammatic notations: survey diagrams, data diagrams,
technique diagrams, task diagrams and process diagrams. SDLTool provides an integrated
environment supporting design, coordination, execution, sharing and publication of complex
statistical survey techniques as web services. SDLTool allows association of model components with
survey artefacts, including data sets, metadata, and statistical package analysis scripts, with the
ability to execute elements of the survey design model to implement survey analysis. Results: We
describe three evaluations of SDL and SDLTool: use of the notation by expert statistician to design
and execute surveys; useability evaluation of the environment; and assessment of several generated
statistical analysis web services. Conclusion: We have shown the effectiveness of SDLTool for
supporting statistical survey design and implementation. Practice implications: We have
developed a more effective approach to supporting statisticians in their survey design work.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Co-developed key ideas for this research, co-designed approach, co-supervised
Masters student, wrote substantial parts of paper, co-lead investigator for funding for this project
from FRST <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jvlc2015.pdf" >PDF</a>
</p> 
<p>
                                                                                            
                                                                                            
</p> 
<p>
                                                                                            
                                                                                            
  </p> 

  <h3 class="sectionHead"><span class="titlemark">7.6   </span> <a 
 id="x1-690007.6"></a>Engineering Complex Data Integration and Harmonization Systems</h3>
<p>Avazpour, I., <strong><span 
class="cmbx-12">Grundy, J.C.</span></strong>, Zhu, L., Engineering Complex Data Integration and Harmonization
Systems, <em><span 
class="cmti-12">Journal of Industrial Information Integration</span></em>, vol 16, Elsevier, Dec 2019
</p> 
<p>  DOI: <a 
href="https://doi.org/10.1016/j.jii.2019.08.001" >10.1016/j.jii.2019.08.001</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Complex data transformation, aggregation and visualization problems are becoming
increasingly common. These are needed in order to support improved business intelligence and
end-user access to data. However, most such applications present very challenging software
engineering problems including noisy data, diverse data formats and APIs, challenging data modeling
and increasing demand for sophisticated visualization support. This paper describes a data
integration, harmonization and visualization process and framework that we have been developing.
We discuss our approach used to tackle complex data aggregation and harmonization
problems and we demonstrate a set of information visualizations that can be developed from
the harmonized data to make it usable for its target audience. We use a case study of
Household Travel Survey data mapping, harmonization, aggregation and visualization to
illustrate our approach. We summarize a set of lessons that we have learned from this
industry-based software engineering experience. We hope these will be useful for others
embarking on challenging data harmonization and integration problems. We also identify
several key directions and needs for future research and practical support in this area.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed many of the key research ideas, co-authored significant parts of the
paper, co-investigator for funding for this project from ARC and co-investigator for funding from
AURIN <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/jiii2019.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="chapterHead"><span class="titlemark">Chapter 8</span><br /><a 
 id="x1-700008"></a>Future Directions</h2>
  <h3 class="sectionHead"><span class="titlemark">8.1   </span> <a 
 id="x1-710008.1"></a>Towards Human-Centric Model-Driven Software Engineering</h3>
<p><strong><span 
class="cmbx-12">Grundy J.C.</span></strong>, Khalajzadeh, H., McIntosh, J., Towards Human-Centric Model-Driven
Software Engineering, <em><span 
class="cmti-12">15th International Conference on Evaluation of Novel Approaches to</span>
<span 
class="cmti-12">Software Engineering (ENASE2020)</span></em>, 5-6 May 2020, Prague, Chez Republic, SitePress, pp.
229-238.
</p> 
<p>  DOI: <a 
href="http://dx.doi.org/10.5220/0009806002290238" >10.5220/0009806002290238</a> <br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">Abstract:</span></strong> Many current software systems suffer from a lack of consideration of the human differences
between end users. This includes age, gender, language, culture, emotions, personality, education,
physical and mental challenges, and so on. We describe our work looking to consider these
characteristics by incorporation of human centric-issues throughout the model-driven engineering
process lifecycle. We propose the use of the co-creational ”living lab” model to better collect
human-centric issues in the software requirements. We focus on modelling these human-centric factors
using domain-specific visual languages, themselves human-centric modelling artefacts. We describe
work to incorporate these human-centric issues into model-driven engineering design models,
and to support both code generation and run-time adaptation to different user human
factors. We discuss continuous evaluation of such human-centric issues in the produced
software and feedback of user reported defects to requirements a nd model refinement.
<br 
class="newline" /><br 
class="newline" /><strong><span 
class="cmbx-12">My contribution:</span></strong> Developed all of the key research ideas, wrote majority of the paper, sole
investigator for funding for this project from the ARC <br 
class="newline" /><br 
class="newline" />Author pre-print available at: <a 
href="https://nzjohng.github.io/publications/papers/enase2020_2.pdf" >PDF</a>
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
                                                                                            
  </p> 

  <h2 class="likechapterHead"><a 
 id="x1-72000"></a>References</h2>
      <div class="thebibliography">
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xagarwal2003object"></a>[1]<span class="bibsp">   </span></span> Agarwal, R. &#x0026; Sinha, A. P. (2003). Object-oriented modeling with uml: a study of
      developers’ perceptions. <span 
class="cmti-12">Communications of the ACM</span>, 46(9), 248–256.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xali2007generic"></a>[2]<span class="bibsp">   </span></span> Ali, N. M. (2007).   A generic visual critic authoring tool.   In <span 
class="cmti-12">IEEE Symposium</span>
      <span 
class="cmti-12">on Visual Languages and Human-Centric Computing (VL/HCC 2007) </span>(pp. 260–261).:
      IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xalmorsy2015supporting"></a>[3]<span class="bibsp">   </span></span> Almorsy, M. &#x0026; Grundy, J. (2015). Supporting scientists in re-engineering sequential
      programs to parallel using model-driven engineering.  In <span 
class="cmti-12">Software Engineering for High</span>
      <span 
class="cmti-12">Performance  Computing  in  Science  (SE4HPCS),  2015  IEEE/ACM  1st  International</span>
      <span 
class="cmti-12">Workshop on </span>(pp. 1–8).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xalmorsy2011collaboration"></a>[4]<span class="bibsp">   </span></span>  Almorsy,  M.,  Grundy,  J.,  &#x0026;  Ibrahim,  A. S.  (2011).   Collaboration-based  cloud
      computing security management framework. In <span 
class="cmti-12">2011 IEEE 4th International Conference</span>
      <span 
class="cmti-12">on Cloud Computing </span>(pp. 364–371).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xalmorsy2014adaptable"></a>[5]<span class="bibsp">   </span></span> Almorsy, M., Grundy, J., &#x0026; Ibrahim, A. S. (2014a). Adaptable, model-driven security
      engineering for saas cloud-based applications.  <span 
class="cmti-12">Automated software engineering</span>, 21(2),
      187–224.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xalmorsy2014horuscml"></a>[6]<span class="bibsp">   </span></span>  Almorsy,  M.,  Grundy,  J.,  &#x0026;  Rüegg,  U.  (2014b).    Horuscml:  Context-aware
      domain-specific visual languages designer. In <span 
class="cmti-12">2014 IEEE Symposium on Visual Languages</span>
      <span 
class="cmti-12">and Human-Centric Computing (VL/HCC) </span>(pp. 133–136).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xavazpour2015specifying"></a>[7]<span class="bibsp">   </span></span> Avazpour, I., Grundy, J., &#x0026; Grunske, L. (2015).  Specifying model transformations
      by direct manipulation using concrete visual notations and interactive recommendations.
      <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 28, 195–211.
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xavazpour2019engineering"></a>[8]<span class="bibsp">   </span></span> Avazpour, I., Grundy, J., &#x0026; Zhu, L. (2019).  Engineering complex data integration,
      harmonization and visualization systems. <span 
class="cmti-12">Journal of Industrial Information Integration</span>,
      16, 100103.
                                                                                            
                                                                                            
      </p>
      <p class="bibitem" ><span class="biblabel">
   <a 
 id="Xbachman1969data"></a>[9]<span class="bibsp">   </span></span> Bachman, C. W. (1969).  Data structure diagrams.  <span 
class="cmti-12">ACM SIGMIS Database: The</span>
      <span 
class="cmti-12">DATABASE for Advances in Information Systems</span>, 1(2), 4–10.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xbarnett2019supporting"></a>[10]<span class="bibsp">   </span></span> Barnett, S., Avazpour, I., Vasa, R., &#x0026; Grundy, J. (2019).  Supporting multi-view
      development for mobile applications. <span 
class="cmti-12">Journal of Computer Languages</span>, 51, 88–96.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xbarnett2015bootstrapping"></a>[11]<span class="bibsp">   </span></span> Barnett, S., Vasa, R., &#x0026; Grundy, J. (2015). Bootstrapping mobile app development.
      In  <span 
class="cmti-12">2015  IEEE/ACM  37th  IEEE  International  Conference  on  Software  Engineering</span>,
      volume 2 (pp. 657–660).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xblackwell2001pictorial"></a>[12]<span class="bibsp">   </span></span> Blackwell, A. F. (2001).  Pictorial representation and metaphor in visual language
      design. <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 12(3), 223–252.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xbohm1966flow"></a>[13]<span class="bibsp">   </span></span> Böhm, C. &#x0026; Jacopini, G. (1966).  Flow diagrams, turing machines and languages
      with only two formation rules. <span 
class="cmti-12">Communications of the ACM</span>, 9(5), 366–371.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xchaudron2012effective"></a>[14]<span class="bibsp">   </span></span>  Chaudron,  M. R.,  Heijstek,  W.,  &#x0026;  Nugroho,  A.  (2012).   How  effective  is  uml
      modeling? <span 
class="cmti-12">Software &#x0026; Systems Modeling</span>, 11(4), 571–580.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xchen2018dctracvis"></a>[15]<span class="bibsp">   </span></span> Chen, X., Hosking, J., Grundy, J., &#x0026; Amor, R. (2018). Dctracvis: a system retrieving
      and visualizing traceability links between source code and documentation.  <span 
class="cmti-12">Automated</span>
      <span 
class="cmti-12">Software Engineering</span>, 25(4), 703–741.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xcook2007domain"></a>[16]<span class="bibsp">   </span></span> Cook, S., Jones, G., Kent, S., &#x0026; Wills, A. C. (2007).  <span 
class="cmti-12">Domain-specific development</span>
      <span 
class="cmti-12">with visual studio dsl tools</span>. Pearson Education.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xcox1989prograph"></a>[17]<span class="bibsp">   </span></span> Cox, P. T., Giles, F., &#x0026; Pietrzykowski, T. (1989). Prograph: a step towards liberating
      programming from textual conditioning. In <span 
class="cmti-12">Visual Languages, 1989., IEEE Workshop on</span>
      (pp. 150–156).: IEEE.
      </p>
                                                                                            
                                                                                            
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xdantra2009domain"></a>[18]<span class="bibsp">   </span></span> Dantra, R., Grundy, J., &#x0026; Hosking, J. (2009). A domain-specific visual language for
      report writing using microsoft dsl tools. In <span 
class="cmti-12">2009 IEEE Symposium on Visual Languages</span>
      <span 
class="cmti-12">and Human-Centric Computing (VL/HCC) </span>(pp. 15–22).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xdraheim2006realistic"></a>[19]<span class="bibsp">   </span></span>  Draheim,  D.,  Grundy,  J.,  Hosking,  J.,  Lutteroth,  C.,  &#x0026;  Weber,  G.  (2006).
      Realistic load testing of web applications.  In <span 
class="cmti-12">Conference on Software Maintenance and</span>
      <span 
class="cmti-12">Reengineering (CSMR’06) </span>(pp. 11–pp).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xesser2001framework"></a>[20]<span class="bibsp">   </span></span> Esser, R. &#x0026; Janneck, J. W. (2001). A framework for defining domain-specific visual
      languages.   In <span 
class="cmti-12">Workshop on Domain Specific Visual Languages, ACM Conference on</span>
      <span 
class="cmti-12">Object-Oriented Programming, Systems, Languages and Applications (OOPSLA-2001)</span>.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xfile1970requirements"></a>[21]<span class="bibsp">   </span></span>  File,  P.,  Castell,  A.,  Marshall,  I.,  Walker,  I.,  &#x0026;  Williams,  L.  (1970).    From
      requirements specification to entity-relationship diagrams using rules. <span 
class="cmti-12">WIT Transactions</span>
      <span 
class="cmti-12">on Information and Communication Technologies</span>, 7.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xfowler2004uml"></a>[22]<span class="bibsp">   </span></span> Fowler, M. (2004).   <span 
class="cmti-12">UML distilled: a brief guide to the standard object modeling</span>
      <span 
class="cmti-12">language</span>. Addison-Wesley Professional.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgreen1996usability"></a>[23]<span class="bibsp">   </span></span> Green, T. R. G. &#x0026; Petre, M. (1996).   Usability analysis of visual programming
      environments:  a  ?cognitive  dimensions?  framework.   <span 
class="cmti-12">Journal  of  Visual  Languages  &#x0026;</span>
      <span 
class="cmti-12">Computing</span>, 7(2), 131–174.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgronback2009eclipse"></a>[24]<span class="bibsp">   </span></span> Gronback, R. C. (2009). <span 
class="cmti-12">Eclipse modeling project: a domain-specific language (DSL)</span>
      <span 
class="cmti-12">toolkit</span>. Pearson Education.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy1999aspect"></a>[25]<span class="bibsp">   </span></span> Grundy, J. (1999).  Aspect-oriented requirements engineering for component-based
      software  systems.    In  <span 
class="cmti-12">Proceedings  IEEE  International  Symposium  on  Requirements</span>
      <span 
class="cmti-12">Engineering (Cat. No. PR00188) </span>(pp. 84–91).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2005softarch"></a>[26]<span class="bibsp">   </span></span>  Grundy,  J.,  Cai,  Y.,  &#x0026;  Liu,  A.  (2005).    Softarch/mte:  Generating  distributed
      system test-beds from high-level software architecture descriptions. <span 
class="cmti-12">Automated Software</span>
      <span 
class="cmti-12">Engineering</span>, 12(1), 5–39.
                                                                                            
                                                                                            
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2002developing"></a>[27]<span class="bibsp">   </span></span>  Grundy,  J.  &#x0026;  Hosking,  J.  (2002a).    Developing  adaptable  user  interfaces  for
      component-based systems. <span 
class="cmti-12">Interacting with computers</span>, 14(3), 175–194.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2002engineering"></a>[28]<span class="bibsp">   </span></span> Grundy, J. &#x0026; Hosking, J. (2002b).   Engineering plug-in software components to
      support collaborative work. <span 
class="cmti-12">Software: Practice and Experience</span>, 32(10), 983–1013.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2003softarch"></a>[29]<span class="bibsp">   </span></span> Grundy, J. &#x0026; Hosking, J. (2003).  Softarch: Tool support for integrated software
      architecture development. <span 
class="cmti-12">International Journal of Software Engineering and Knowledge</span>
      <span 
class="cmti-12">Engineering</span>, 13(02), 125–151.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2007supporting"></a>[30]<span class="bibsp">   </span></span>  Grundy,  J.  &#x0026;  Hosking,  J.  (2007).   Supporting  generic  sketching-based  input  of
      diagrams in a domain-specific visual language meta-tool. In <span 
class="cmti-12">29th International Conference</span>
      <span 
class="cmti-12">on Software Engineering (ICSE’07) </span>(pp. 282–291).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2007experiences"></a>[31]<span class="bibsp">   </span></span> Grundy, J., Hosking, J., Cao, S., Zhao, D., Zhu, N., Tempero, E., &#x0026; Stoeckle, H.
      (2007).   Experiences developing architectures for realizing thin-client diagram editing
      tools. <span 
class="cmti-12">Software: Practice and Experience</span>, 37(12), 1245–1283.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy1998inconsistency"></a>[32]<span class="bibsp">   </span></span> Grundy, J., Hosking, J., &#x0026; Mugridge, W. B. (1998a).  Inconsistency management
      for multiple-view software development environments.  <span 
class="cmti-12">IEEE Transactions on Software</span>
      <span 
class="cmti-12">Engineering</span>, 24(11), 960–981.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2020towards"></a>[33]<span class="bibsp">   </span></span>  Grundy,  J.,  Khalajzadeh,  H.,  &#x0026;  Mcintosh,  J.  (2020).    Towards  human-centric
      model-driven software engineering. In <span 
class="cmti-12">ENASE </span>(pp. 229–238).
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2001generating"></a>[34]<span class="bibsp">   </span></span>  Grundy,  J.,  Mugridge,  R.,  Hosking,  J.,  &#x0026;  Kendall,  P.  (2001).   Generating  edi
      message translations from visual specifications. In <span 
class="cmti-12">Proceedings 16th Annual International</span>
      <span 
class="cmti-12">Conference on Automated Software Engineering (ASE 2001) </span>(pp. 35–42).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2000constructing"></a>[35]<span class="bibsp">   </span></span> Grundy, J., Mugridge, W., &#x0026; Hosking, J. (2000).  Constructing component-based
      software engineering environments: issues and experiences.   <span 
class="cmti-12">Information and Software</span>
      <span 
class="cmti-12">Technology</span>, 42(2), 103–114.
                                                                                            
                                                                                            
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy1998decentralized"></a>[36]<span class="bibsp">   </span></span> Grundy, J. C., Apperley, M. D., Hosking, J. G., &#x0026; Mugridge, W. B. (1998b).  A
      decentralized architecture for software process modeling and enactment.  <span 
class="cmti-12">IEEE Internet</span>
      <span 
class="cmti-12">Computing</span>, 2(5), 53–62.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2012generating"></a>[37]<span class="bibsp">   </span></span> Grundy, J. C., Hosking, J., Li, K. N., Ali, N. M., Huh, J., &#x0026; Li, R. L. (2012).
      Generating  domain-specific  visual  language  tools  from  abstract  visual  specifications.
      <span 
class="cmti-12">IEEE Transactions on Software Engineering</span>, 39(4), 487–515.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy1996constructing"></a>[38]<span class="bibsp">   </span></span>  Grundy,  J. C.  &#x0026;  Hosking,  J. G.  (1996).     Constructing  integrated  software
      development  environments  with  mviews.   <span 
class="cmti-12">International  Journal  of  Applied  Software</span>
      <span 
class="cmti-12">Technology</span>, 2(3-4), 133–160.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy1998serendipity"></a>[39]<span class="bibsp">   </span></span>  Grundy,  J. C.  &#x0026;  Hosking,  J. G.  (1998).    Serendipity:  integrated  environment
      support for process modelling, enactment and work coordination. In <span 
class="cmti-12">Process Technology</span>
      (pp. 27–60). Springer.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xgrundy2004domain"></a>[40]<span class="bibsp">   </span></span>  Grundy,  J. C.,  Hosking,  J. G.,  Amor,  R.,  Mugridge,  W. B.,  &#x0026;  Li,  Y.  (2004).
      Domain-specific visual languages for specifying and generating data mapping systems.
      <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 15(3-4), 243–263.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xguerra2009supporting"></a>[41]<span class="bibsp">   </span></span> Guerra, E., de Lara, J., Malizia, A., &#x0026; Díaz, P. (2009).  Supporting user-oriented
      analysis  for  multi-view  domain-specific  visual  languages.   <span 
class="cmti-12">Information  and  Software</span>
      <span 
class="cmti-12">Technology</span>, 51(4), 769–784.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xharel1987statecharts"></a>[42]<span class="bibsp">   </span></span> Harel, D. (1987).  Statecharts: A visual formalism for complex systems.  <span 
class="cmti-12">Science of</span>
      <span 
class="cmti-12">computer programming</span>, 8(3), 231–274.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xhenderson1999line"></a>[43]<span class="bibsp">   </span></span> Henderson, K. (1999). <span 
class="cmti-12">On line and on paper: Visual representations, visual culture,</span>
      <span 
class="cmti-12">and computer graphics in design engineering</span>. JSTOR.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xhirsch2010vikibuilder"></a>[44]<span class="bibsp">   </span></span> Hirsch, C., Hosking, J., &#x0026; Grundy, J. (2010). Vikibuilder: end-user specification and
      generation of visual wikis. In <span 
class="cmti-12">Proceedings of the IEEE/ACM international conference on</span>
      <span 
class="cmti-12">Automated software engineering </span>(pp. 13–22).
                                                                                            
                                                                                            
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xhuh2009integrated"></a>[45]<span class="bibsp">   </span></span> Huh, J., Grundy, J., Hosking, J., Liu, K., &#x0026; Amor, R. (2009).   Integrated data
      mapping for a software meta-tool.  In <span 
class="cmti-12">2009 Australian Software Engineering Conference</span>
      (pp. 111–120).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xkamalrudin2017maramaaic"></a>[46]<span class="bibsp">   </span></span> Kamalrudin, M., Hosking, J., &#x0026; Grundy, J. (2017).  Maramaaic: tool support for
      consistency management and validation of requirements. <span 
class="cmti-12">Automated software engineering</span>,
      24(1), 1–45.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xkhalajzadeh2020end"></a>[47]<span class="bibsp">   </span></span> Khalajzadeh, H., Simmons, A. J., Abdelrazek, M., Grundy, J., Hosking, J., &#x0026; He, Q.
      (2020). An end-to-end model-based approach to support big data analytics development.
      <span 
class="cmti-12">Journal of Computer Languages</span>, 58, 100964.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xkhambati2008model"></a>[48]<span class="bibsp">   </span></span>  Khambati,  A.,  Grundy,  J.,  Warren,  J.,  &#x0026;  Hosking,  J.  (2008).    Model-driven
      development  of  mobile  personal  health  care  applications.   In  <span 
class="cmti-12">2008 23rd IEEE/ACM</span>
      <span 
class="cmti-12">International Conference on Automated Software Engineering </span>(pp. 467–470).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xkim2015suite"></a>[49]<span class="bibsp">   </span></span> Kim, C. H., Grundy, J., &#x0026; Hosking, J. (2015).   A suite of visual languages for
      model-driven development of statistical surveys and services. <span 
class="cmti-12">Journal of Visual Languages</span>
      <span 
class="cmti-12">&#x0026; Computing</span>, 26, 99–125.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xkim2005suite"></a>[50]<span class="bibsp">   </span></span> Kim, C. H., Hosking, J., &#x0026; Grundy, J. (2005).   A suite of visual languages for
      statistical  survey  specification.   In  <span 
class="cmti-12">2005 IEEE Symposium on Visual Languages and</span>
      <span 
class="cmti-12">Human-Centric Computing (VL/HCC’05) </span>(pp. 19–26).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xledeczi2001composing"></a>[51]<span class="bibsp">   </span></span> Lédeczi, Á., Bakay, A., Maroti, M., Volgyesi, P., Nordstrom, G., Sprinkle, J., &#x0026;
      Karsai, G. (2001).  Composing domain-specific design environments.  <span 
class="cmti-12">Computer</span>, 34(11),
      44–51.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xli2014visual"></a>[52]<span class="bibsp">   </span></span> Li, L., Grundy, J., &#x0026; Hosking, J. (2014).  A visual language and environment for
      enterprise system modelling and automation. <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>,
      25(4), 253–277.
      </p>
                                                                                            
                                                                                            
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xli2002data"></a>[53]<span class="bibsp">   </span></span> Li, Y., Grundy, J., Amor, R., &#x0026; Hosking, J. (2002).  A data mapping specification
      environment using a concrete business form-based metaphor. In <span 
class="cmti-12">Proceedings IEEE 2002</span>
      <span 
class="cmti-12">Symposia on Human Centric Computing Languages and Environments </span>(pp. 158–166).:
      IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xliu2016domain"></a>[54]<span class="bibsp">   </span></span> Liu, J., Grundy, J., Avazpour, I., &#x0026; Abdelrazek, M. (2016). A domain-specific visual
      modeling language for testing environment emulation.   In <span 
class="cmti-12">2016 IEEE Symposium on</span>
      <span 
class="cmti-12">Visual Languages and Human-Centric Computing (VL/HCC) </span>(pp. 143–151).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xludewig2003models"></a>[55]<span class="bibsp">   </span></span> Ludewig, J. (2003).  Models in software engineering–an introduction.  <span 
class="cmti-12">Software and</span>
      <span 
class="cmti-12">Systems Modeling</span>, 2(1), 5–14.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xmaplesden2001visual"></a>[56]<span class="bibsp">   </span></span> Maplesden, D., Hosking, J. G., &#x0026; Grundy, J. C. (2001). A visual language for design
      pattern modelling and instantiation. In <span 
class="cmti-12">HCC </span>(pp. 338–339).: Citeseer.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xmehra2005generic"></a>[57]<span class="bibsp">   </span></span> Mehra, A., Grundy, J., &#x0026; Hosking, J. (2005).  A generic approach to supporting
      diagram differencing and merging for collaborative design.  In <span 
class="cmti-12">Proceedings of the 20th</span>
      <span 
class="cmti-12">IEEE/ACM international Conference on Automated software engineering </span>(pp. 204–213).
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xmernik2005and"></a>[58]<span class="bibsp">   </span></span>  Mernik,  M.,  Heering,  J.,  &#x0026;  Sloane,  A. M.  (2005).   When  and  how  to  develop
      domain-specific languages. <span 
class="cmti-12">ACM computing surveys (CSUR)</span>, 37(4), 316–344.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="XMoody2009"></a>[59]<span class="bibsp">   </span></span>  Moody,  D.  (2009).    The  “physics”  of  notations:  Toward  a  scientific  basis  for
      constructing visual notations in software engineering.  <span 
class="cmti-12">IEEE Trans. Softw. Eng.</span>, 35(6),
      756–779.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xmyers1990taxonomies"></a>[60]<span class="bibsp">   </span></span> Myers, B. A. (1990). Taxonomies of visual programming and program visualization.
      <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 1(1), 97–123.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xpanas20033d"></a>[61]<span class="bibsp">   </span></span> Panas, T., Berrigan, R., &#x0026; Grundy, J. (2003). A 3d metaphor for software production
      visualization.    In  <span 
class="cmti-12">Proceedings  on  Seventh  International  Conference  on  Information</span>
      <span 
class="cmti-12">Visualization, 2003. IV 2003. </span>(pp. 314–319).: IEEE.
      </p>
                                                                                            
                                                                                            
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xparnas1969use"></a>[62]<span class="bibsp">   </span></span> Parnas, D. L. (1969).  On the use of transition diagrams in the design of a user
      interface for an interactive computer system.  In <span 
class="cmti-12">Proceedings of the 1969 24th national</span>
      <span 
class="cmti-12">conference </span>(pp. 379–385).
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xpelechano2006building"></a>[63]<span class="bibsp">   </span></span> Pelechano, V., Albert, M., Muñoz, J., &#x0026; Cetina, C. (2006). Building tools for model
      driven development. comparing microsoft dsl tools and eclipse modeling plug-ins.   In
      <span 
class="cmti-12">DSDM</span>.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xpetre2013uml"></a>[64]<span class="bibsp">   </span></span> Petre, M. (2013). Uml in practice. In <span 
class="cmti-12">2013 35th international conference on software</span>
      <span 
class="cmti-12">engineering (icse) </span>(pp. 722–731).: IEEE.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xplanas2020uml"></a>[65]<span class="bibsp">   </span></span>  Planas,  E.  &#x0026;  Cabot,  J.  (2020).   How  are  uml  class  diagrams  built  in  practice?
      a usability study of two uml tools: Magicdraw and papyrus.   <span 
class="cmti-12">Computer Standards &#x0026;</span>
      <span 
class="cmti-12">Interfaces</span>, 67, 103363.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xschmidt2006model"></a>[66]<span class="bibsp">   </span></span>  Schmidt,  D. C.  (2006).   Model-driven  engineering.   <span 
class="cmti-12">Computer-IEEE  Computer</span>
      <span 
class="cmti-12">Society-</span>, 39(2), 25.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xshneiderman19931"></a>[67]<span class="bibsp">   </span></span>  Shneiderman,  B.  (1993).   1.1  direct  manipulation:  a  step  beyond  programming
      languages. <span 
class="cmti-12">Sparks of innovation in human-computer interaction</span>, 17, 1993.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xshu1988visual"></a>[68]<span class="bibsp">   </span></span> Shu, N. C. (1988). <span 
class="cmti-12">Visual programming</span>. Van Nostrand Reinhold New York.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xsprinkle2004domain"></a>[69]<span class="bibsp">   </span></span> Sprinkle, J. &#x0026; Karsai, G. (2004). A domain-specific visual language for domain model
      evolution. <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 15(3), 291–307.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xthiagarajan2002bpml"></a>[70]<span class="bibsp">   </span></span>  Thiagarajan,  R. K.,  Srivastava,  A. K.,  Pujari,  A. K.,  &#x0026;  Bulusu,  V. K.  (2002).
      Bpml: a process modeling language for dynamic business models. In <span 
class="cmti-12">Advanced Issues of</span>
      <span 
class="cmti-12">E-Commerce and Web-Based Information Systems, 2002.(WECWIS 2002). Proceedings.</span>
      <span 
class="cmti-12">Fourth IEEE International Workshop on </span>(pp. 222–224).: IEEE.
      </p>
                                                                                            
                                                                                            
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xtolvanen2003metaedit+"></a>[71]<span class="bibsp">   </span></span> Tolvanen, J.-P. &#x0026; Rossi, M. (2003).  Metaedit+: defining and using domain-specific
      modeling  languages  and  code  generators.      In  <span 
class="cmti-12">Companion  of  the  18th  annual</span>
      <span 
class="cmti-12">ACM SIGPLAN conference on Object-oriented programming, systems, languages, and</span>
      <span 
class="cmti-12">applications </span>(pp. 92–93).: ACM.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xwhitley1997visual"></a>[72]<span class="bibsp">   </span></span> Whitley, K. N. (1997).  Visual programming languages and the empirical evidence
      for and against. <span 
class="cmti-12">Journal of Visual Languages &#x0026; Computing</span>, 8(1), 109–142.
      </p>
      <p class="bibitem" ><span class="biblabel">
  <a 
 id="Xzhu2007pounamu"></a>[73]<span class="bibsp">   </span></span> Zhu, N., Grundy, J., Hosking, J., Liu, N., Cao, S., &#x0026; Mehra, A. (2007). Pounamu: A
      meta-tool for exploratory domain-specific visual language tool development.  <span 
class="cmti-12">Journal of</span>
      <span 
class="cmti-12">Systems and Software</span>, 80(8), 1390–1407.
</p>
      </div>
<a 
 id="Q1-1-85"></a>
                                                                                            
                                                                                            
<p>
                                                                                            
                                                                                            
  </p> 

<div class="center" 
>
<p>
</p> 
<p><span class="lettrine"><span class="lettrine-letter"><span class="lettrine-<span id="textcolor1">T</span>"><span id="textcolor2">T</span></span> </span></span><span class="lettrine-line">his thesis was typeset</span> using LaTeX,
originally developed by Leslie Lamport
and  based  on  Donald  Knuth’s  TeX.
The  body  text  is  set  in  11  point
Egenolff-Berner Garamond, a revival of
Claude                           Garamont’s
humanist typeface.A template that can
be used to format a PhD dissertation
with   this   look   <em><span 
class="cmti-12">&#x0026;</span></em>   feel   has   been
released  under  the  permissive  <span 
class="cmcsc-10x-x-120"><span 
class="small-caps">a</span><span 
class="small-caps">g</span><span 
class="small-caps">p</span><span 
class="small-caps">l</span></span>
license,  and  can  be  found  online  at
<a 
href="https://github.com/suchow/Dissertate" >github.com/suchow/Dissertate</a> or from
its  lead  author,  Jordan  Suchow,  at
<a 
href="mailto:suchow@post.harvard.edu" >suchow@post.harvard.edu</a>.            </p> 
</div>
                                                                                            
                                                                                            
   
</body> 
</html>
                                                                                            


